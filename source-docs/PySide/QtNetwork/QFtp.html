

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>QFtp &mdash; PySide 1.1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/pysidedocs.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="PySide 1.1.0 documentation" href="../../index.html" />
    <link rel="up" title="PySide.QtNetwork" href="index.html" />
    <link rel="next" title="QAbstractNetworkCache" href="QAbstractNetworkCache.html" />
    <link rel="prev" title="QHttp" href="QHttp.html" /> 
  </head>
  <body>
<div id="container">
<div class="header">
    <div class="header_container">
        <div class="logo"><a href="http://www.pyside.org"><img alt="PySide" src="../../_static/pysidelogo.png" width="199" height="102" /></a></div>
        <div class="related">
            <ul>
                <li><a href="../../index.html">PySide 1.1.0 documentation</a></li>
                <li> &raquo; <a href="../../modules.html" >PySide modules</a></li>
                <li> &raquo; <a href="index.html" accesskey="U">PySide.QtNetwork</a></li> 
            </ul>
        </div>
    </div>
</div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QFtp</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#slots">Slots</a></li>
<li><a class="reference internal" href="#signals">Signals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="QHttp.html"
                        title="previous chapter">QHttp</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="QAbstractNetworkCache.html"
                        title="next chapter">QAbstractNetworkCache</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-PySide.QtNetwork"></span><div class="section" id="qftp">
<span id="id1"></span><h1>QFtp<a class="headerlink" href="#qftp" title="Permalink to this headline">¶</a></h1>
<p class="graphviz">
<img src="../../_images/inheritance-3fcb3c8280a4372059fbfc64de73ffe7cb6fb538.png" alt="Inheritance diagram of QFtp" usemap="#inheritancec3cbd02dc9" class="inheritance"/>
<map id="inheritancec3cbd02dc9" name="inheritancec3cbd02dc9">
<area shape="rect" id="node1" href="../QtCore/QObject.html#PySide.QtCore.QObject" title="QtCore.QObject" alt="" coords="5,5,128,33"/>
<area shape="rect" id="node2" href="#PySide.QtNetwork.QFtp" title="QtNetwork.QFtp" alt="" coords="176,5,299,33"/>
</map>
</p>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.bytesAvailable" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.bytesAvailable"><tt class="xref py py-meth docutils literal"><span class="pre">bytesAvailable</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.cd" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.cd"><tt class="xref py py-meth docutils literal"><span class="pre">cd</span></tt></a> (dir)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.clearPendingCommands" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.clearPendingCommands"><tt class="xref py py-meth docutils literal"><span class="pre">clearPendingCommands</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.close" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.close"><tt class="xref py py-meth docutils literal"><span class="pre">close</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">connectToHost</span></tt></a> (host[, port=21])</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand"><tt class="xref py py-meth docutils literal"><span class="pre">currentCommand</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentDevice" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentDevice"><tt class="xref py py-meth docutils literal"><span class="pre">currentDevice</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentId" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentId"><tt class="xref py py-meth docutils literal"><span class="pre">currentId</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.error" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.error"><tt class="xref py py-meth docutils literal"><span class="pre">error</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.errorString" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.errorString"><tt class="xref py py-meth docutils literal"><span class="pre">errorString</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.get" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.get"><tt class="xref py py-meth docutils literal"><span class="pre">get</span></tt></a> (file[, dev=None[, type=Binary]])</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.hasPendingCommands" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.hasPendingCommands"><tt class="xref py py-meth docutils literal"><span class="pre">hasPendingCommands</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.list" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.list"><tt class="xref py py-meth docutils literal"><span class="pre">list</span></tt></a> ([dir=&#8221;&#8220;])</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.login" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.login"><tt class="xref py py-meth docutils literal"><span class="pre">login</span></tt></a> ([user=&#8221;&#8220;[, password=&#8221;&#8220;]])</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.mkdir" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.mkdir"><tt class="xref py py-meth docutils literal"><span class="pre">mkdir</span></tt></a> (dir)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.put" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.put"><tt class="xref py py-meth docutils literal"><span class="pre">put</span></tt></a> (data, file[, type=Binary])</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.put" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.put"><tt class="xref py py-meth docutils literal"><span class="pre">put</span></tt></a> (dev, file[, type=Binary])</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommand" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommand"><tt class="xref py py-meth docutils literal"><span class="pre">rawCommand</span></tt></a> (command)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.read" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.read"><tt class="xref py py-meth docutils literal"><span class="pre">read</span></tt></a> (, maxlen)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll"><tt class="xref py py-meth docutils literal"><span class="pre">readAll</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.remove" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.remove"><tt class="xref py py-meth docutils literal"><span class="pre">remove</span></tt></a> (file)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rename" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.rename"><tt class="xref py py-meth docutils literal"><span class="pre">rename</span></tt></a> (oldname, newname)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rmdir" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.rmdir"><tt class="xref py py-meth docutils literal"><span class="pre">rmdir</span></tt></a> (dir)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.setProxy" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.setProxy"><tt class="xref py py-meth docutils literal"><span class="pre">setProxy</span></tt></a> (host, port)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.setTransferMode" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.setTransferMode"><tt class="xref py py-meth docutils literal"><span class="pre">setTransferMode</span></tt></a> (mode)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.state" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.state"><tt class="xref py py-meth docutils literal"><span class="pre">state</span></tt></a> ()</li>
</ul>
</div>
<div class="section" id="slots">
<h3>Slots<a class="headerlink" href="#slots" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.abort" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.abort"><tt class="xref py py-meth docutils literal"><span class="pre">abort</span></tt></a> ()</li>
</ul>
</div>
<div class="section" id="signals">
<h3>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">commandFinished</span></tt></a> (arg__1, arg__2)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">commandStarted</span></tt></a> (arg__1)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.dataTransferProgress" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.dataTransferProgress"><tt class="xref py py-meth docutils literal"><span class="pre">dataTransferProgress</span></tt></a> (arg__1, arg__2)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.done" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.done"><tt class="xref py py-meth docutils literal"><span class="pre">done</span></tt></a> (arg__1)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.listInfo" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.listInfo"><tt class="xref py py-meth docutils literal"><span class="pre">listInfo</span></tt></a> (arg__1)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommandReply" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommandReply"><tt class="xref py py-meth docutils literal"><span class="pre">rawCommandReply</span></tt></a> (arg__1, arg__2)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">readyRead</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged"><tt class="xref py py-meth docutils literal"><span class="pre">stateChanged</span></tt></a> (arg__1)</li>
</ul>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide.QtNetwork.QFtp" title="PySide.QtNetwork.QFtp"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QFtp</span></tt></a> class provides an implementation of the client side of FTP protocol.</p>
<p>This class provides a direct interface to FTP that allows you to have more control over the requests. However, for new applications, it is recommended to use <a class="reference internal" href="QNetworkAccessManager.html#PySide.QtNetwork.QNetworkAccessManager" title="PySide.QtNetwork.QNetworkAccessManager"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkAccessManager</span></tt></a> and <a class="reference internal" href="QNetworkReply.html#PySide.QtNetwork.QNetworkReply" title="PySide.QtNetwork.QNetworkReply"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkReply</span></tt></a> , as those classes possess a simpler, yet more powerful API.</p>
<p>The class works asynchronously, so there are no blocking functions. If an operation cannot be executed immediately, the function will still return straight away and the operation will be scheduled for later execution. The results of scheduled operations are reported via signals. This approach depends on the event loop being in operation.</p>
<p>The operations that can be scheduled (they are called &#8220;commands&#8221; in the rest of the documentation) are the following: <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.connectToHost()</span></tt></a> , <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.login" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.login"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.login()</span></tt></a> , <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.close" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.close"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.close()</span></tt></a> , <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.list" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.list"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.list()</span></tt></a> , <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.cd" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.cd"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.cd()</span></tt></a> , <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.get" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.get"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.get()</span></tt></a> , <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.put" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.put"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.put()</span></tt></a> , <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.remove" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.remove"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.remove()</span></tt></a> , <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.mkdir" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.mkdir"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.mkdir()</span></tt></a> , <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rmdir" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.rmdir"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.rmdir()</span></tt></a> , <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rename" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.rename"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.rename()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommand" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommand"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.rawCommand()</span></tt></a> .</p>
<p>All of these commands return a unique identifier that allows you to keep track of the command that is currently being executed. When the execution of a command starts, the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal with the command&#8217;s identifier is emitted. When the command is finished, the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted with the command&#8217;s identifier and a bool that indicates whether the command finished with an error.</p>
<p>In some cases, you might want to execute a sequence of commands, e.g. if you want to connect and login to a FTP server. This is simply achieved:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ftp</span> <span class="o">=</span> <span class="n">QFtp</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="n">ftp</span><span class="o">.</span><span class="n">connectToHost</span><span class="p">(</span><span class="s">&quot;ftp.trolltech.com&quot;</span><span class="p">)</span>
<span class="n">ftp</span><span class="o">.</span><span class="n">login</span><span class="p">()</span>
</pre></div>
</div>
<p>In this case two FTP commands have been scheduled. When the last scheduled command has finished, a <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.done" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.done"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.done()</span></tt></a> signal is emitted with a bool argument that tells you whether the sequence finished with an error.</p>
<p>If an error occurs during the execution of one of the commands in a sequence of commands, all the pending commands (i.e. scheduled, but not yet executed commands) are cleared and no signals are emitted for them.</p>
<p>Some commands, e.g. <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.list" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.list"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.list()</span></tt></a> , emit additional signals to report their results.</p>
<p>Example: If you want to download the INSTALL file from the Qt FTP server, you would write this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ftp</span><span class="o">.</span><span class="n">connectToHost</span><span class="p">(</span><span class="s">&quot;ftp.trolltech.com&quot;</span><span class="p">)</span> <span class="c"># id == 1</span>
<span class="n">ftp</span><span class="o">.</span><span class="n">login</span><span class="p">()</span>                            <span class="c"># id == 2</span>
<span class="n">ftp</span><span class="o">.</span><span class="n">cd</span><span class="p">(</span><span class="s">&quot;qt&quot;</span><span class="p">)</span>                           <span class="c"># id == 3</span>
<span class="n">ftp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;INSTALL&quot;</span><span class="p">)</span>                     <span class="c"># id == 4</span>
<span class="n">ftp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>                            <span class="c"># id == 5</span>
</pre></div>
</div>
<p>For this example the following sequence of signals is emitted (with small variations, depending on network traffic, etc.):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">start</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">stateChanged</span><span class="p">(</span><span class="n">HostLookup</span><span class="p">)</span>
<span class="n">stateChanged</span><span class="p">(</span><span class="n">Connecting</span><span class="p">)</span>
<span class="n">stateChanged</span><span class="p">(</span><span class="n">Connected</span><span class="p">)</span>
<span class="n">finished</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>

<span class="n">start</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">stateChanged</span><span class="p">(</span><span class="n">LoggedIn</span><span class="p">)</span>
<span class="n">finished</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>

<span class="n">start</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">finished</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>

<span class="n">start</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">dataTransferProgress</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3798</span><span class="p">)</span>
<span class="n">dataTransferProgress</span><span class="p">(</span><span class="mi">2896</span><span class="p">,</span> <span class="mi">3798</span><span class="p">)</span>
<span class="n">readyRead</span><span class="p">()</span>
<span class="n">dataTransferProgress</span><span class="p">(</span><span class="mi">3798</span><span class="p">,</span> <span class="mi">3798</span><span class="p">)</span>
<span class="n">readyRead</span><span class="p">()</span>
<span class="n">finished</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>

<span class="n">start</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">stateChanged</span><span class="p">(</span><span class="n">Closing</span><span class="p">)</span>
<span class="n">stateChanged</span><span class="p">(</span><span class="n">Unconnected</span><span class="p">)</span>
<span class="n">finished</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>

<span class="n">done</span><span class="p">(</span><span class="n">false</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.dataTransferProgress" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.dataTransferProgress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.dataTransferProgress()</span></tt></a> signal in the above example is useful if you want to show a <a class="reference internal" href="../QtGui/QProgressBar.html#PySide.QtGui.QProgressBar" title="PySide.QtGui.QProgressBar"><tt class="xref py py-class docutils literal"><span class="pre">progress</span> <span class="pre">bar</span></tt></a> to inform the user about the progress of the download. The <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readyRead()</span></tt></a> signal tells you that there is data ready to be read. The amount of data can be queried then with the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.bytesAvailable" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.bytesAvailable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.bytesAvailable()</span></tt></a> function and it can be read with the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.read" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.read()</span></tt></a> or <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readAll()</span></tt></a> function.</p>
<p>If the login fails for the above example, the signals would look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">start</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">stateChanged</span><span class="p">(</span><span class="n">HostLookup</span><span class="p">)</span>
<span class="n">stateChanged</span><span class="p">(</span><span class="n">Connecting</span><span class="p">)</span>
<span class="n">stateChanged</span><span class="p">(</span><span class="n">Connected</span><span class="p">)</span>
<span class="n">finished</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>

<span class="n">start</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">finished</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">true</span><span class="p">)</span>

<span class="n">done</span><span class="p">(</span><span class="n">true</span><span class="p">)</span>
</pre></div>
</div>
<p>You can then get details about the error with the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.error" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.error"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.error()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.errorString" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.errorString"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.errorString()</span></tt></a> functions.</p>
<p>For file transfer, <a class="reference internal" href="#PySide.QtNetwork.QFtp" title="PySide.QtNetwork.QFtp"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QFtp</span></tt></a> can use both active or passive mode, and it uses passive file transfer mode by default; see the documentation for <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.setTransferMode" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.setTransferMode"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.setTransferMode()</span></tt></a> for more details about this.</p>
<p>Call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.setProxy" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.setProxy"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.setProxy()</span></tt></a> to make <a class="reference internal" href="#PySide.QtNetwork.QFtp" title="PySide.QtNetwork.QFtp"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QFtp</span></tt></a> connect via an FTP proxy server.</p>
<p>The functions <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentId" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentId"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.currentId()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.currentCommand()</span></tt></a> provide more information about the currently executing command.</p>
<p>The functions <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.hasPendingCommands" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.hasPendingCommands"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.hasPendingCommands()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.clearPendingCommands" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.clearPendingCommands"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.clearPendingCommands()</span></tt></a> allow you to query and clear the list of pending commands.</p>
<p>If you are an experienced network programmer and want to have complete control you can use <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommand" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommand"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.rawCommand()</span></tt></a> to execute arbitrary FTP commands.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The current version of <a class="reference internal" href="#PySide.QtNetwork.QFtp" title="PySide.QtNetwork.QFtp"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QFtp</span></tt></a> doesn&#8217;t fully support non-Unix FTP servers.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QNetworkAccessManager.html#PySide.QtNetwork.QNetworkAccessManager" title="PySide.QtNetwork.QNetworkAccessManager"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkAccessManager</span></tt></a>  <a class="reference internal" href="QNetworkRequest.html#PySide.QtNetwork.QNetworkRequest" title="PySide.QtNetwork.QNetworkRequest"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkRequest</span></tt></a>  <a class="reference internal" href="QNetworkReply.html#PySide.QtNetwork.QNetworkReply" title="PySide.QtNetwork.QNetworkReply"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkReply</span></tt></a>  <em class="xref std std-ref">FTP Example</em></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide.QtNetwork.QFtp">
<em class="property">class </em><tt class="descclassname">PySide.QtNetwork.</tt><tt class="descname">QFtp</tt><big>(</big><span class="optional">[</span><em>parent=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.QFtp" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parent</strong> &#8211; <a class="reference internal" href="../QtCore/QObject.html#PySide.QtCore.QObject" title="PySide.QtCore.QObject"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QObject</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Constructs a <a class="reference internal" href="#PySide.QtNetwork.QFtp" title="PySide.QtNetwork.QFtp"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QFtp</span></tt></a> object with the given <tt class="docutils literal"><span class="pre">parent</span></tt> .</p>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.TransferType">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">TransferType</tt><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.TransferType" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum identifies the data transfer type used with get and put commands.</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QFtp.Binary</td>
<td>The data will be transferred in Binary mode.</td>
</tr>
<tr class="row-odd"><td>QFtp.Ascii</td>
<td>The data will be transferred in Ascii mode and new line characters will be converted to the local format.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.Error">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">Error</tt><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.Error" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum identifies the error that occurred.</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QFtp.NoError</td>
<td>No error occurred.</td>
</tr>
<tr class="row-odd"><td>QFtp.HostNotFound</td>
<td>The host name lookup failed.</td>
</tr>
<tr class="row-even"><td>QFtp.ConnectionRefused</td>
<td>The server refused the connection.</td>
</tr>
<tr class="row-odd"><td>QFtp.NotConnected</td>
<td>Tried to send a command, but there is no connection to a server.</td>
</tr>
<tr class="row-even"><td>QFtp.UnknownError</td>
<td>An error other than those specified above occurred.</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.error" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.error"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.error()</span></tt></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.Command">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">Command</tt><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.Command" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum is used as the return value for the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.currentCommand()</span></tt></a> function. This allows you to perform specific actions for particular commands, e.g. in a FTP client, you might want to clear the directory view when a <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.list" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.list"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.list()</span></tt></a> command is started; in this case you can simply check in the slot connected to the start() signal if the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.currentCommand()</span></tt></a> is <tt class="docutils literal"><span class="pre">List</span></tt> .</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QFtp.None</td>
<td>No command is being executed.</td>
</tr>
<tr class="row-odd"><td>QFtp.SetTransferMode</td>
<td>set the <tt class="xref py py-attr docutils literal"><span class="pre">transfer</span></tt> mode.</td>
</tr>
<tr class="row-even"><td>QFtp.SetProxy</td>
<td>switch proxying on or off.</td>
</tr>
<tr class="row-odd"><td>QFtp.ConnectToHost</td>
<td><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.connectToHost()</span></tt></a> is being executed.</td>
</tr>
<tr class="row-even"><td>QFtp.Login</td>
<td><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.login" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.login"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.login()</span></tt></a> is being executed.</td>
</tr>
<tr class="row-odd"><td>QFtp.Close</td>
<td><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.close" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.close"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.close()</span></tt></a> is being executed.</td>
</tr>
<tr class="row-even"><td>QFtp.List</td>
<td><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.list" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.list"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.list()</span></tt></a> is being executed.</td>
</tr>
<tr class="row-odd"><td>QFtp.Cd</td>
<td><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.cd" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.cd"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.cd()</span></tt></a> is being executed.</td>
</tr>
<tr class="row-even"><td>QFtp.Get</td>
<td><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.get" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.get"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.get()</span></tt></a> is being executed.</td>
</tr>
<tr class="row-odd"><td>QFtp.Put</td>
<td><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.put" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.put"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.put()</span></tt></a> is being executed.</td>
</tr>
<tr class="row-even"><td>QFtp.Remove</td>
<td><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.remove" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.remove"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.remove()</span></tt></a> is being executed.</td>
</tr>
<tr class="row-odd"><td>QFtp.Mkdir</td>
<td><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.mkdir" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.mkdir"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.mkdir()</span></tt></a> is being executed.</td>
</tr>
<tr class="row-even"><td>QFtp.Rmdir</td>
<td><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rmdir" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.rmdir"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.rmdir()</span></tt></a> is being executed.</td>
</tr>
<tr class="row-odd"><td>QFtp.Rename</td>
<td><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rename" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.rename"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.rename()</span></tt></a> is being executed.</td>
</tr>
<tr class="row-even"><td>QFtp.RawCommand</td>
<td><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommand" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommand"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.rawCommand()</span></tt></a> is being executed.</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.currentCommand()</span></tt></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.TransferMode">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">TransferMode</tt><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.TransferMode" title="Permalink to this definition">¶</a></dt>
<dd><p>FTP works with two socket connections; one for commands and another for transmitting data. While the command connection is always initiated by the client, the second connection can be initiated by either the client or the server.</p>
<p>This enum defines whether the client (Passive mode) or the server (Active mode) should set up the data connection.</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QFtp.Passive</td>
<td>The client connects to the server to transmit its data.</td>
</tr>
<tr class="row-odd"><td>QFtp.Active</td>
<td>The server connects to the client to transmit its data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.State">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">State</tt><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.State" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum defines the connection state:</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QFtp.Unconnected</td>
<td>There is no connection to the host.</td>
</tr>
<tr class="row-odd"><td>QFtp.HostLookup</td>
<td>A host name lookup is in progress.</td>
</tr>
<tr class="row-even"><td>QFtp.Connecting</td>
<td>An attempt to connect to the host is in progress.</td>
</tr>
<tr class="row-odd"><td>QFtp.Connected</td>
<td>Connection to the host has been achieved.</td>
</tr>
<tr class="row-even"><td>QFtp.LoggedIn</td>
<td>Connection and user login have been achieved.</td>
</tr>
<tr class="row-odd"><td>QFtp.Closing</td>
<td>The connection is closing down, but it is not yet closed. (The state will be <tt class="docutils literal"><span class="pre">Unconnected</span></tt> when the connection is closed.)</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.stateChanged()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.state" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.state"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.state()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.abort">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">abort</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Aborts the current command and deletes all scheduled commands.</p>
<p>If there is an unfinished command (i.e. a command for which the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal has been emitted, but for which the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal has not been emitted), this function sends an <tt class="docutils literal"><span class="pre">ABORT</span></tt> command to the server. When the server replies that the command is aborted, the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal with the <tt class="docutils literal"><span class="pre">error</span></tt> argument set to <tt class="docutils literal"><span class="pre">true</span></tt> is emitted for the command. Due to timing issues, it is possible that the command had already finished before the abort request reached the server, in which case, the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted with the <tt class="docutils literal"><span class="pre">error</span></tt> argument set to <tt class="docutils literal"><span class="pre">false</span></tt> .</p>
<p>For all other commands that are affected by the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.abort" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.abort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.abort()</span></tt></a> , no signals are emitted.</p>
<p>If you don&#8217;t start further FTP commands directly after the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.abort" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.abort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.abort()</span></tt></a> , there won&#8217;t be any scheduled commands and the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.done" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.done"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.done()</span></tt></a> signal is emitted.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Some FTP servers, for example the BSD FTP daemon (version 0.3), wrongly return a positive reply even when an abort has occurred. For these servers the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal has its error flag set to <tt class="docutils literal"><span class="pre">false</span></tt> , even though the command did not complete successfully.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.clearPendingCommands" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.clearPendingCommands"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.clearPendingCommands()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.bytesAvailable">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">bytesAvailable</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.bytesAvailable" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns the number of bytes that can be read from the data socket at the moment.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.get" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.get"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.get()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readyRead()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.read" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.read()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readAll()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.cd">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">cd</tt><big>(</big><em>dir</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.cd" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dir</strong> &#8211; unicode</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
<p>Changes the working directory of the server to <tt class="docutils literal"><span class="pre">dir</span></tt> .</p>
<p>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> .</p>
<p>When the command is started the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal is emitted. When it is finished the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.clearPendingCommands">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">clearPendingCommands</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.clearPendingCommands" title="Permalink to this definition">¶</a></dt>
<dd><p>Deletes all pending commands from the list of scheduled commands. This does not affect the command that is being executed. If you want to stop this as well, use <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.abort" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.abort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.abort()</span></tt></a> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.hasPendingCommands" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.hasPendingCommands"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.hasPendingCommands()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.abort" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.abort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.abort()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.close">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.close" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
<p>Closes the connection to the FTP server.</p>
<p>The <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.stateChanged()</span></tt></a> signal is emitted when the state of the connecting process changes, e.g. to <tt class="docutils literal"><span class="pre">Closing</span></tt> , then <tt class="docutils literal"><span class="pre">Unconnected</span></tt> .</p>
<p>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> .</p>
<p>When the command is started the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal is emitted. When it is finished the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.stateChanged()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">commandFinished</tt><big>(</big><em>arg__1</em>, <em>arg__2</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arg__1</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
<li><strong>arg__2</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">commandStarted</tt><big>(</big><em>arg__1</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arg__1</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.connectToHost">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">connectToHost</tt><big>(</big><em>host</em><span class="optional">[</span>, <em>port=21</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.connectToHost" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>host</strong> &#8211; unicode</li>
<li><strong>port</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>Connects to the FTP server <tt class="docutils literal"><span class="pre">host</span></tt> using port <tt class="docutils literal"><span class="pre">port</span></tt> .</p>
<p>The <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.stateChanged()</span></tt></a> signal is emitted when the state of the connecting process changes, e.g. to <tt class="docutils literal"><span class="pre">HostLookup</span></tt> , then <tt class="docutils literal"><span class="pre">Connecting</span></tt> , then <tt class="docutils literal"><span class="pre">Connected</span></tt> .</p>
<p>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> .</p>
<p>When the command is started the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal is emitted. When it is finished the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.stateChanged()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">currentCommand</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.Command" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.Command"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QFtp.Command</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the command type of the FTP command being executed or <tt class="docutils literal"><span class="pre">None</span></tt> if there is no command being executed.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentId" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentId"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.currentId()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentDevice">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">currentDevice</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentDevice" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> pointer that is used by the FTP command to read data from or store data to. If there is no current FTP command being executed or if the command does not use an IO device, this function returns 0.</p>
<p>This function can be used to delete the <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> in the slot connected to the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.get" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.get"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.get()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.put" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.put"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.put()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentId">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">currentId</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentId" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns the identifier of the FTP command that is being executed or 0 if there is no command being executed.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.currentCommand()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.dataTransferProgress">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">dataTransferProgress</tt><big>(</big><em>arg__1</em>, <em>arg__2</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.dataTransferProgress" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arg__1</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></li>
<li><strong>arg__2</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.done">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">done</tt><big>(</big><em>arg__1</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.done" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arg__1</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.error">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">error</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.error" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.Error" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.Error"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QFtp.Error</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the last error that occurred. This is useful to find out what went wrong when receiving a <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> or a <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.done" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.done"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.done()</span></tt></a> signal with the <tt class="docutils literal"><span class="pre">error</span></tt> argument set to <tt class="docutils literal"><span class="pre">true</span></tt> .</p>
<p>If you start a new command, the error status is reset to <tt class="docutils literal"><span class="pre">NoError</span></tt> .</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.errorString">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">errorString</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.errorString" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">unicode</td>
</tr>
</tbody>
</table>
<p>Returns a human-readable description of the last error that occurred. This is useful for presenting a error message to the user when receiving a <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> or a <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.done" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.done"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.done()</span></tt></a> signal with the <tt class="docutils literal"><span class="pre">error</span></tt> argument set to <tt class="docutils literal"><span class="pre">true</span></tt> .</p>
<p>The error string is often (but not always) the reply from the server, so it is not always possible to translate the string. If the message comes from Qt, the string has already passed through <tt class="xref py py-meth docutils literal"><span class="pre">tr()</span></tt> .</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.get">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">get</tt><big>(</big><em>file</em><span class="optional">[</span>, <em>dev=None</em><span class="optional">[</span>, <em>type=Binary</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.get" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file</strong> &#8211; unicode</li>
<li><strong>dev</strong> &#8211; <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a></li>
<li><strong>type</strong> &#8211; <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.TransferType" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.TransferType"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QFtp.TransferType</span></tt></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>Downloads the file <tt class="docutils literal"><span class="pre">file</span></tt> from the server.</p>
<p>If <tt class="docutils literal"><span class="pre">dev</span></tt> is 0, then the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readyRead()</span></tt></a> signal is emitted when there is data available to read. You can then read the data with the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.read" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.read()</span></tt></a> or <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readAll()</span></tt></a> functions.</p>
<p>If <tt class="docutils literal"><span class="pre">dev</span></tt> is not 0, the data is written directly to the device <tt class="docutils literal"><span class="pre">dev</span></tt> . Make sure that the <tt class="docutils literal"><span class="pre">dev</span></tt> pointer is valid for the duration of the operation (it is safe to delete it when the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted). In this case the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readyRead()</span></tt></a> signal is <em>not</em> emitted and you cannot read data with the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.read" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.read()</span></tt></a> or <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readAll()</span></tt></a> functions.</p>
<p>If you don&#8217;t read the data immediately it becomes available, i.e. when the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readyRead()</span></tt></a> signal is emitted, it is still available until the next command is started.</p>
<p>For example, if you want to present the data to the user as soon as there is something available, connect to the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readyRead()</span></tt></a> signal and read the data immediately. On the other hand, if you only want to work with the complete data, you can connect to the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal and read the data when the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.get" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.get"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.get()</span></tt></a> command is finished.</p>
<p>The data is transferred as Binary or Ascii depending on the value of <tt class="docutils literal"><span class="pre">type</span></tt> .</p>
<p>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> .</p>
<p>When the command is started the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal is emitted. When it is finished the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted.</p>
<p><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a></p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readyRead()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.dataTransferProgress" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.dataTransferProgress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.dataTransferProgress()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.hasPendingCommands">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">hasPendingCommands</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.hasPendingCommands" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if there are any commands scheduled that have not yet been executed; otherwise returns false.</p>
<p>The command that is being executed is <em>not</em> considered as a scheduled command.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.clearPendingCommands" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.clearPendingCommands"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.clearPendingCommands()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentId" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentId"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.currentId()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.currentCommand"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.currentCommand()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.list">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">list</tt><big>(</big><span class="optional">[</span><em>dir=&quot;&quot;</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.list" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dir</strong> &#8211; unicode</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
<p>Lists the contents of directory <tt class="docutils literal"><span class="pre">dir</span></tt> on the FTP server. If <tt class="docutils literal"><span class="pre">dir</span></tt> is empty, it lists the contents of the current directory.</p>
<p>The <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.listInfo" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.listInfo"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.listInfo()</span></tt></a> signal is emitted for each directory entry found.</p>
<p>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> .</p>
<p>When the command is started the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal is emitted. When it is finished the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.listInfo" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.listInfo"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.listInfo()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.listInfo">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">listInfo</tt><big>(</big><em>arg__1</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.listInfo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arg__1</strong> &#8211; <a class="reference internal" href="QUrlInfo.html#PySide.QtNetwork.QUrlInfo" title="PySide.QtNetwork.QUrlInfo"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUrlInfo</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.login">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">login</tt><big>(</big><span class="optional">[</span><em>user=&quot;&quot;</em><span class="optional">[</span>, <em>password=&quot;&quot;</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.login" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>user</strong> &#8211; unicode</li>
<li><strong>password</strong> &#8211; unicode</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>Logs in to the FTP server with the username <tt class="docutils literal"><span class="pre">user</span></tt> and the password <tt class="docutils literal"><span class="pre">password</span></tt> .</p>
<p>The <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.stateChanged()</span></tt></a> signal is emitted when the state of the connecting process changes, e.g. to <tt class="docutils literal"><span class="pre">LoggedIn</span></tt> .</p>
<p>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> .</p>
<p>When the command is started the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal is emitted. When it is finished the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.mkdir">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">mkdir</tt><big>(</big><em>dir</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.mkdir" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dir</strong> &#8211; unicode</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
<p>Creates a directory called <tt class="docutils literal"><span class="pre">dir</span></tt> on the server.</p>
<p>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> .</p>
<p>When the command is started the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal is emitted. When it is finished the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.put">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">put</tt><big>(</big><em>dev</em>, <em>file</em><span class="optional">[</span>, <em>type=Binary</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.put" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dev</strong> &#8211; <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a></li>
<li><strong>file</strong> &#8211; unicode</li>
<li><strong>type</strong> &#8211; <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.TransferType" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.TransferType"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QFtp.TransferType</span></tt></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>Reads the data from the IO device <tt class="docutils literal"><span class="pre">dev</span></tt> , and writes it to the file called <tt class="docutils literal"><span class="pre">file</span></tt> on the server. The data is read in chunks from the IO device, so this overload allows you to transmit large amounts of data without the need to read all the data into memory at once.</p>
<p>The data is transferred as Binary or Ascii depending on the value of <tt class="docutils literal"><span class="pre">type</span></tt> .</p>
<p>Make sure that the <tt class="docutils literal"><span class="pre">dev</span></tt> pointer is valid for the duration of the operation (it is safe to delete it when the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> is emitted).</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">put</tt><big>(</big><em>data</em>, <em>file</em><span class="optional">[</span>, <em>type=Binary</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> &#8211; <a class="reference internal" href="../QtCore/QByteArray.html#PySide.QtCore.QByteArray" title="PySide.QtCore.QByteArray"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QByteArray</span></tt></a></li>
<li><strong>file</strong> &#8211; unicode</li>
<li><strong>type</strong> &#8211; <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.TransferType" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.TransferType"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QFtp.TransferType</span></tt></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Writes a copy of the given <tt class="docutils literal"><span class="pre">data</span></tt> to the file called <tt class="docutils literal"><span class="pre">file</span></tt> on the server. The progress of the upload is reported by the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.dataTransferProgress" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.dataTransferProgress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.dataTransferProgress()</span></tt></a> signal.</p>
<p>The data is transferred as Binary or Ascii depending on the value of <tt class="docutils literal"><span class="pre">type</span></tt> .</p>
<p>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> .</p>
<p>When the command is started the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal is emitted. When it is finished the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted.</p>
<p>Since this function takes a copy of the <tt class="docutils literal"><span class="pre">data</span></tt> , you can discard your own copy when this function returns.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.dataTransferProgress" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.dataTransferProgress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.dataTransferProgress()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommand">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">rawCommand</tt><big>(</big><em>command</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommand" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>command</strong> &#8211; unicode</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
<p>Sends the raw FTP command <tt class="docutils literal"><span class="pre">command</span></tt> to the FTP server. This is useful for low-level FTP access. If the operation you wish to perform has an equivalent <a class="reference internal" href="#PySide.QtNetwork.QFtp" title="PySide.QtNetwork.QFtp"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QFtp</span></tt></a> function, we recommend using the function instead of raw FTP commands since the functions are easier and safer.</p>
<p>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> .</p>
<p>When the command is started the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal is emitted. When it is finished the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommandReply" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommandReply"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.rawCommandReply()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommandReply">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">rawCommandReply</tt><big>(</big><em>arg__1</em>, <em>arg__2</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rawCommandReply" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>arg__1</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
<li><strong>arg__2</strong> &#8211; unicode</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.read">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">read</tt><big>(</big><em>maxlen</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.read" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxlen</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">QByteArray</td>
</tr>
</tbody>
</table>
<p>Reads <tt class="docutils literal"><span class="pre">maxlen</span></tt> bytes from the data socket into <tt class="docutils literal"><span class="pre">data</span></tt> and returns the number of bytes read. Returns -1 if an error occurred.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.get" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.get"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.get()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readyRead()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.bytesAvailable" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.bytesAvailable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.bytesAvailable()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readAll()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">readAll</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readAll" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../QtCore/QByteArray.html#PySide.QtCore.QByteArray" title="PySide.QtCore.QByteArray"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QByteArray</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Reads all the bytes available from the data socket and returns them.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.get" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.get"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.get()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.readyRead()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.bytesAvailable" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.bytesAvailable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.bytesAvailable()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.read" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.read()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">readyRead</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.readyRead" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.remove">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">remove</tt><big>(</big><em>file</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.remove" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>file</strong> &#8211; unicode</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
<p>Deletes the file called <tt class="docutils literal"><span class="pre">file</span></tt> from the server.</p>
<p>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> .</p>
<p>When the command is started the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal is emitted. When it is finished the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.rename">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">rename</tt><big>(</big><em>oldname</em>, <em>newname</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rename" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>oldname</strong> &#8211; unicode</li>
<li><strong>newname</strong> &#8211; unicode</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>Renames the file called <tt class="docutils literal"><span class="pre">oldname</span></tt> to <tt class="docutils literal"><span class="pre">newname</span></tt> on the server.</p>
<p>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> .</p>
<p>When the command is started the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal is emitted. When it is finished the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.rmdir">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">rmdir</tt><big>(</big><em>dir</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.rmdir" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dir</strong> &#8211; unicode</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
<p>Removes the directory called <tt class="docutils literal"><span class="pre">dir</span></tt> from the server.</p>
<p>The function does not block and returns immediately. The command is scheduled, and its execution is performed asynchronously. The function returns a unique identifier which is passed by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> .</p>
<p>When the command is started the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a> signal is emitted. When it is finished the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a> signal is emitted.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandStarted"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandStarted()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.commandFinished"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.commandFinished()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.setProxy">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">setProxy</tt><big>(</big><em>host</em>, <em>port</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.setProxy" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>host</strong> &#8211; unicode</li>
<li><strong>port</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>Enables use of the FTP proxy on host <tt class="docutils literal"><span class="pre">host</span></tt> and port <tt class="docutils literal"><span class="pre">port</span></tt> . Calling this function with <tt class="docutils literal"><span class="pre">host</span></tt> empty disables proxying.</p>
<p><a class="reference internal" href="#PySide.QtNetwork.QFtp" title="PySide.QtNetwork.QFtp"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QFtp</span></tt></a> does not support FTP-over-HTTP proxy servers. Use <a class="reference internal" href="QNetworkAccessManager.html#PySide.QtNetwork.QNetworkAccessManager" title="PySide.QtNetwork.QNetworkAccessManager"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkAccessManager</span></tt></a> for this.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.setTransferMode">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">setTransferMode</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.setTransferMode" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mode</strong> &#8211; <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.TransferMode" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.TransferMode"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QFtp.TransferMode</span></tt></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
<p>Sets the current FTP transfer mode to <tt class="docutils literal"><span class="pre">mode</span></tt> . The default is <tt class="xref py py-attr docutils literal"><span class="pre">QFtp.Passive</span></tt> .</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-attr docutils literal"><span class="pre">QFtp.TransferMode</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.state">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">state</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.state" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.State" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.State"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QFtp.State</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the current state of the object. When the state changes, the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.stateChanged()</span></tt></a> signal is emitted.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-attr docutils literal"><span class="pre">QFtp.State</span></tt>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged" title="PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QFtp.stateChanged()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged">
<tt class="descclassname">PySide.QtNetwork.QFtp.</tt><tt class="descname">stateChanged</tt><big>(</big><em>arg__1</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QFtp.stateChanged" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arg__1</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    <a href="http://www.indt.org.br"><img src="../../_static/logo_indt.jpg" alt="Indt" border="0" /></a>
    <a href="http://www.openbossa.org"><img src="../../_static/logo_openbossa.png" alt="Openbossa" border="0" /></a>
    <a href="http://qt.nokia.com/"><img src="../../_static/logo_qt.png" alt="Qt" border="0" /></a>
    <a href="http://www.python.org"><img src="../../_static/logo_python.jpg" alt="Python" border="0" /></a>
    </div>
</div>
  </body>
</html>