

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>QGLWidget &mdash; PySide 1.1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/pysidedocs.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="PySide 1.1.0 documentation" href="../../index.html" />
    <link rel="up" title="PySide.QtOpenGL" href="index.html" />
    <link rel="next" title="PySide.QtScript" href="../QtScript/index.html" />
    <link rel="prev" title="QGLShader" href="QGLShader.html" /> 
  </head>
  <body>
<div id="container">
<div class="header">
    <div class="header_container">
        <div class="logo"><a href="http://www.pyside.org"><img alt="PySide" src="../../_static/pysidelogo.png" width="199" height="102" /></a></div>
        <div class="related">
            <ul>
                <li><a href="../../index.html">PySide 1.1.0 documentation</a></li>
                <li> &raquo; <a href="../../modules.html" >PySide modules</a></li>
                <li> &raquo; <a href="index.html" accesskey="U">PySide.QtOpenGL</a></li> 
            </ul>
        </div>
    </div>
</div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QGLWidget</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#virtual-functions">Virtual functions</a></li>
<li><a class="reference internal" href="#static-functions">Static functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a><ul>
<li><a class="reference internal" href="#overlays">Overlays</a></li>
<li><a class="reference internal" href="#painting-techniques">Painting Techniques</a></li>
<li><a class="reference internal" href="#threading">Threading</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="QGLShader.html"
                        title="previous chapter">QGLShader</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../QtScript/index.html"
                        title="next chapter">PySide.QtScript</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-PySide.QtOpenGL"></span><div class="section" id="qglwidget">
<span id="id1"></span><h1>QGLWidget<a class="headerlink" href="#qglwidget" title="Permalink to this headline">¶</a></h1>
<p class="graphviz">
<img src="../../_images/inheritance-40903d3350df8dfe6f4edbceaceb527b3950e5bf.png" alt="Inheritance diagram of QGLWidget" usemap="#inheritance32c69a60fa" class="inheritance"/>
<map id="inheritance32c69a60fa" name="inheritance32c69a60fa">
<area shape="rect" id="node1" href="../QtGui/QWidget.html#PySide.QtGui.QWidget" title="QtGui.QWidget" alt="" coords="200,30,315,58"/>
<area shape="rect" id="node6" href="#PySide.QtOpenGL.QGLWidget" title="QtOpenGL.QGLWidget" alt="" coords="364,30,524,58"/>
<area shape="rect" id="node2" href="../QtCore/QObject.html#PySide.QtCore.QObject" title="QtCore.QObject" alt="" coords="17,5,140,33"/>
<area shape="rect" id="node4" href="../QtGui/QPaintDevice.html#PySide.QtGui.QPaintDevice" title="QtGui.QPaintDevice" alt="" coords="5,55,152,83"/>
</map>
</p>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.autoBufferSwap" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.autoBufferSwap"><tt class="xref py py-meth docutils literal"><span class="pre">autoBufferSwap</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture"><tt class="xref py py-meth docutils literal"><span class="pre">bindTexture</span></tt></a> (fileName)</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture"><tt class="xref py py-meth docutils literal"><span class="pre">bindTexture</span></tt></a> (image, target, format, options)</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture"><tt class="xref py py-meth docutils literal"><span class="pre">bindTexture</span></tt></a> (image[, target=0x0DE1[, format=0x1908]])</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture"><tt class="xref py py-meth docutils literal"><span class="pre">bindTexture</span></tt></a> (pixmap, target, format, options)</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture"><tt class="xref py py-meth docutils literal"><span class="pre">bindTexture</span></tt></a> (pixmap[, target=0x0DE1[, format=0x1908]])</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.colormap" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.colormap"><tt class="xref py py-meth docutils literal"><span class="pre">colormap</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.context" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.context"><tt class="xref py py-meth docutils literal"><span class="pre">context</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.deleteTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.deleteTexture"><tt class="xref py py-meth docutils literal"><span class="pre">deleteTexture</span></tt></a> (tx_id)</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.doneCurrent" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.doneCurrent"><tt class="xref py py-meth docutils literal"><span class="pre">doneCurrent</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.doubleBuffer" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.doubleBuffer"><tt class="xref py py-meth docutils literal"><span class="pre">doubleBuffer</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.drawTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.drawTexture"><tt class="xref py py-meth docutils literal"><span class="pre">drawTexture</span></tt></a> (point, textureId[, textureTarget=0x0DE1])</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.drawTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.drawTexture"><tt class="xref py py-meth docutils literal"><span class="pre">drawTexture</span></tt></a> (target, textureId[, textureTarget=0x0DE1])</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.format" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.format"><tt class="xref py py-meth docutils literal"><span class="pre">format</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.grabFrameBuffer" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.grabFrameBuffer"><tt class="xref py py-meth docutils literal"><span class="pre">grabFrameBuffer</span></tt></a> ([withAlpha=false])</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.isSharing" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.isSharing"><tt class="xref py py-meth docutils literal"><span class="pre">isSharing</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.isValid" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">isValid</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent"><tt class="xref py py-meth docutils literal"><span class="pre">makeCurrent</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeOverlayCurrent" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeOverlayCurrent"><tt class="xref py py-meth docutils literal"><span class="pre">makeOverlayCurrent</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.overlayContext" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.overlayContext"><tt class="xref py py-meth docutils literal"><span class="pre">overlayContext</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglClearColor" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglClearColor"><tt class="xref py py-meth docutils literal"><span class="pre">qglClearColor</span></tt></a> (c)</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglColor" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglColor"><tt class="xref py py-meth docutils literal"><span class="pre">qglColor</span></tt></a> (c)</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.renderPixmap" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.renderPixmap"><tt class="xref py py-meth docutils literal"><span class="pre">renderPixmap</span></tt></a> ([w=0[, h=0[, useContext=false]]])</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.renderText" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.renderText"><tt class="xref py py-meth docutils literal"><span class="pre">renderText</span></tt></a> (x, y, str[, fnt=QFont()[, listBase=2000]])</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.renderText" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.renderText"><tt class="xref py py-meth docutils literal"><span class="pre">renderText</span></tt></a> (x, y, z, str[, fnt=QFont()[, listBase=2000]])</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setAutoBufferSwap" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setAutoBufferSwap"><tt class="xref py py-meth docutils literal"><span class="pre">setAutoBufferSwap</span></tt></a> (on)</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setColormap" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setColormap"><tt class="xref py py-meth docutils literal"><span class="pre">setColormap</span></tt></a> (map)</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.swapBuffers" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.swapBuffers"><tt class="xref py py-meth docutils literal"><span class="pre">swapBuffers</span></tt></a> ()</li>
</ul>
</div>
<div class="section" id="virtual-functions">
<h3>Virtual functions<a class="headerlink" href="#virtual-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.glDraw" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.glDraw"><tt class="xref py py-meth docutils literal"><span class="pre">glDraw</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.glInit" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.glInit"><tt class="xref py py-meth docutils literal"><span class="pre">glInit</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL"><tt class="xref py py-meth docutils literal"><span class="pre">initializeGL</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">initializeOverlayGL</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">paintGL</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">paintOverlayGL</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL"><tt class="xref py py-meth docutils literal"><span class="pre">resizeGL</span></tt></a> (w, h)</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">resizeOverlayGL</span></tt></a> (w, h)</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.updateGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.updateGL"><tt class="xref py py-meth docutils literal"><span class="pre">updateGL</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.updateOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.updateOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">updateOverlayGL</span></tt></a> ()</li>
</ul>
</div>
<div class="section" id="static-functions">
<h3>Static functions<a class="headerlink" href="#static-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.convertToGLFormat" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.convertToGLFormat"><tt class="xref py py-meth docutils literal"><span class="pre">convertToGLFormat</span></tt></a> (img)</li>
</ul>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> class is a widget for rendering OpenGL graphics.</p>
<p><a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> provides functionality for displaying OpenGL graphics integrated into a Qt application. It is very simple to use. You inherit from it and use the subclass like any other <a class="reference internal" href="../QtGui/QWidget.html#PySide.QtGui.QWidget" title="PySide.QtGui.QWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QWidget</span></tt></a> , except that you have the choice between using <a class="reference internal" href="../QtGui/QPainter.html#PySide.QtGui.QPainter" title="PySide.QtGui.QPainter"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QPainter</span></tt></a> and standard OpenGL rendering commands.</p>
<p><a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> provides three convenient virtual functions that you can reimplement in your subclass to perform the typical OpenGL tasks:</p>
<ul class="simple">
<li><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintGL()</span></tt></a> - Renders the OpenGL scene. Gets called whenever the widget needs to be updated.</li>
<li><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.resizeGL()</span></tt></a> - Sets up the OpenGL viewport, projection, etc. Gets called whenever the widget has been resized (and also when it is shown for the first time because all newly created widgets get a resize event automatically).</li>
<li><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.initializeGL()</span></tt></a> - Sets up the OpenGL rendering context, defines display lists, etc. Gets called once before the first time <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.resizeGL()</span></tt></a> or <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintGL()</span></tt></a> is called.</li>
</ul>
<p>Here is a rough outline of how a <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> subclass might look:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyGLDrawer</span><span class="p">(</span><span class="n">QGLWidget</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="n">QGLWidget</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">initializeGL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Set up the rendering context, define display lists etc.:</span>
        <span class="o">...</span>
        <span class="n">glClearColor</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">)</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">resizeGL</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
        <span class="c"># setup viewport, projection etc.:</span>
        <span class="n">glViewport</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="o">...</span>
        <span class="n">glFrustum</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">paintGL</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># draw the scene:</span>
        <span class="o">...</span>
        <span class="n">glRotatef</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="n">glMaterialfv</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="n">glBegin</span><span class="p">(</span><span class="n">GL_QUADS</span><span class="p">)</span>
        <span class="n">glVertex3f</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="n">glVertex3f</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="o">...</span>
        <span class="n">glEnd</span><span class="p">()</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>If you need to trigger a repaint from places other than <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintGL()</span></tt></a> (a typical example is when using <a class="reference internal" href="../QtCore/QTimer.html#PySide.QtCore.QTimer" title="PySide.QtCore.QTimer"><tt class="xref py py-class docutils literal"><span class="pre">timers</span></tt></a> to animate scenes), you should call the widget&#8217;s <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.updateGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.updateGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.updateGL()</span></tt></a> function.</p>
<p>Your widget&#8217;s OpenGL rendering context is made current when <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintGL()</span></tt></a> , <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.resizeGL()</span></tt></a> , or <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.initializeGL()</span></tt></a> is called. If you need to call the standard OpenGL API functions from other places (e.g. in your widget&#8217;s constructor or in your own paint functions), you must call <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.makeCurrent()</span></tt></a> first.</p>
<p><a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> provides functions for requesting a new display <a class="reference internal" href="QGLFormat.html#PySide.QtOpenGL.QGLFormat" title="PySide.QtOpenGL.QGLFormat"><tt class="xref py py-class docutils literal"><span class="pre">format</span></tt></a> and you can also create widgets with customized rendering <a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.QGLContext" title="PySide.QtOpenGL.QGLContext"><tt class="xref py py-class docutils literal"><span class="pre">contexts</span></tt></a> .</p>
<p>You can also share OpenGL display lists between <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> objects (see the documentation of the <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> constructors for details).</p>
<p>Note that under Windows, the <a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.QGLContext" title="PySide.QtOpenGL.QGLContext"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLContext</span></tt></a> belonging to a <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> has to be recreated when the <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> is reparented. This is necessary due to limitations on the Windows platform. This will most likely cause problems for users that have subclassed and installed their own <a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.QGLContext" title="PySide.QtOpenGL.QGLContext"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLContext</span></tt></a> on a <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> . It is possible to work around this issue by putting the <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> inside a dummy widget and then reparenting the dummy widget, instead of the <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> . This will side-step the issue altogether, and is what we recommend for users that need this kind of functionality.</p>
<p>On Mac OS X, when Qt is built with Cocoa support, a <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> can&#8217;t have any sibling widgets placed ontop of itself. This is due to limitations in the Cocoa API and is not supported by Apple.</p>
</div></blockquote>
<div class="section" id="overlays">
<span id="pyside-qtopengl-qglwidget-overlays"></span><h3>Overlays<a class="headerlink" href="#overlays" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> creates a GL overlay context in addition to the normal context if overlays are supported by the underlying system.</p>
<p>If you want to use overlays, you specify it in the <a class="reference internal" href="QGLFormat.html#PySide.QtOpenGL.QGLFormat" title="PySide.QtOpenGL.QGLFormat"><tt class="xref py py-class docutils literal"><span class="pre">format</span></tt></a> . (Note: Overlay must be requested in the format passed to the <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> constructor.) Your GL widget should also implement some or all of these virtual methods:</p>
<ul class="simple">
<li><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintOverlayGL()</span></tt></a></li>
<li><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.resizeOverlayGL()</span></tt></a></li>
<li><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.initializeOverlayGL()</span></tt></a></li>
</ul>
<p>These methods work in the same way as the normal <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintGL()</span></tt></a> etc. functions, except that they will be called when the overlay context is made current. You can explicitly make the overlay context current by using <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeOverlayCurrent" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeOverlayCurrent"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.makeOverlayCurrent()</span></tt></a> , and you can access the overlay context directly (e.g. to ask for its transparent color) by calling <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.overlayContext" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.overlayContext"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.overlayContext()</span></tt></a> .</p>
<p>On X servers in which the default visual is in an overlay plane, non-GL Qt windows can also be used for overlays.</p>
</div></blockquote>
</div>
<div class="section" id="painting-techniques">
<span id="pyside-qtopengl-qglwidget-painting-techniques"></span><h3>Painting Techniques<a class="headerlink" href="#painting-techniques" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>As described above, subclass <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> to render pure 3D content in the following way:</p>
<ul class="simple">
<li>Reimplement the <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL"><tt class="xref py py-meth docutils literal"><span class="pre">QGLWidget.initializeGL()</span></tt></a> and <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL"><tt class="xref py py-meth docutils literal"><span class="pre">QGLWidget.resizeGL()</span></tt></a> to set up the OpenGL state and provide a perspective transformation.</li>
<li>Reimplement <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">QGLWidget.paintGL()</span></tt></a> to paint the 3D scene, calling only OpenGL functions to draw on the widget.</li>
</ul>
<p>It is also possible to draw 2D graphics onto a <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> subclass, it is necessary to reimplement <tt class="xref py py-meth docutils literal"><span class="pre">QGLWidget.paintEvent()</span></tt> and do the following:</p>
<ul class="simple">
<li>Construct a <a class="reference internal" href="../QtGui/QPainter.html#PySide.QtGui.QPainter" title="PySide.QtGui.QPainter"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QPainter</span></tt></a> object.</li>
<li>Initialize it for use on the widget with the <tt class="xref py py-meth docutils literal"><span class="pre">QPainter.begin()</span></tt> function.</li>
<li>Draw primitives using <a class="reference internal" href="../QtGui/QPainter.html#PySide.QtGui.QPainter" title="PySide.QtGui.QPainter"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QPainter</span></tt></a> &#8216;s member functions.</li>
<li>Call <tt class="xref py py-meth docutils literal"><span class="pre">QPainter.end()</span></tt> to finish painting.</li>
</ul>
<p>Overpainting 2D content on top of 3D content takes a little more effort. One approach to doing this is shown in the <em class="xref std std-ref">Overpainting</em> example.</p>
</div></blockquote>
</div>
<div class="section" id="threading">
<span id="pyside-qtopengl-qglwidget-threading"></span><h3>Threading<a class="headerlink" href="#threading" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>It is possible to render into a <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> from another thread, but it requires that all access to the GL context is safe guarded. The Qt GUI thread will try to use the context in resizeEvent and paintEvent, so in order for threaded rendering using a GL widget to work, these functions need to be intercepted in the GUI thread and handled accordingly in the application.</p>
<p><em>OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other countries.</em></p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QGLPixelBuffer.html#PySide.QtOpenGL.QGLPixelBuffer" title="PySide.QtOpenGL.QGLPixelBuffer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLPixelBuffer</span></tt></a>  <em class="xref std std-ref">Hello GL Example</em>  <em class="xref std std-ref">2D Painting Example</em>  <em class="xref std std-ref">Overpainting Example</em>  <em class="xref std std-ref">Grabber Example</em></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide.QtOpenGL.QGLWidget">
<em class="property">class </em><tt class="descclassname">PySide.QtOpenGL.</tt><tt class="descname">QGLWidget</tt><big>(</big><em>context</em><span class="optional">[</span>, <em>parent=None</em><span class="optional">[</span>, <em>shareWidget=None</em><span class="optional">[</span>, <em>f=0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.QGLWidget" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property">class </em><tt class="descclassname">PySide.QtOpenGL.</tt><tt class="descname">QGLWidget</tt><big>(</big><span class="optional">[</span><em>parent=None</em><span class="optional">[</span>, <em>shareWidget=None</em><span class="optional">[</span>, <em>f=0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big></dt>
<dt>
<em class="property">class </em><tt class="descclassname">PySide.QtOpenGL.</tt><tt class="descname">QGLWidget</tt><big>(</big><em>format</em><span class="optional">[</span>, <em>parent=None</em><span class="optional">[</span>, <em>shareWidget=None</em><span class="optional">[</span>, <em>f=0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>shareWidget</strong> &#8211; <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a></li>
<li><strong>f</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.Qt.WindowFlags</span></tt></li>
<li><strong>format</strong> &#8211; <a class="reference internal" href="QGLFormat.html#PySide.QtOpenGL.QGLFormat" title="PySide.QtOpenGL.QGLFormat"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLFormat</span></tt></a></li>
<li><strong>context</strong> &#8211; <a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.QGLContext" title="PySide.QtOpenGL.QGLContext"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLContext</span></tt></a></li>
<li><strong>parent</strong> &#8211; <a class="reference internal" href="../QtGui/QWidget.html#PySide.QtGui.QWidget" title="PySide.QtGui.QWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QWidget</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.autoBufferSwap">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">autoBufferSwap</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.autoBufferSwap" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if the widget is doing automatic GL buffer swapping; otherwise returns false.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setAutoBufferSwap" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setAutoBufferSwap"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.setAutoBufferSwap()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">bindTexture</tt><big>(</big><em>pixmap</em>, <em>target</em>, <em>format</em>, <em>options</em><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pixmap</strong> &#8211; <a class="reference internal" href="../QtGui/QPixmap.html#PySide.QtGui.QPixmap" title="PySide.QtGui.QPixmap"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QPixmap</span></tt></a></li>
<li><strong>target</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLenum</span></tt></li>
<li><strong>format</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLint</span></tt></li>
<li><strong>options</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLContext.BindOptions</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLuint</span></tt></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">bindTexture</tt><big>(</big><em>pixmap</em><span class="optional">[</span>, <em>target=0x0DE1</em><span class="optional">[</span>, <em>format=0x1908</em><span class="optional">]</span><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pixmap</strong> &#8211; <a class="reference internal" href="../QtGui/QPixmap.html#PySide.QtGui.QPixmap" title="PySide.QtGui.QPixmap"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QPixmap</span></tt></a></li>
<li><strong>target</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLenum</span></tt></li>
<li><strong>format</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLint</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLuint</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>Calls QGLContext:::bindTexture(<tt class="docutils literal"><span class="pre">pixmap</span></tt> , <tt class="docutils literal"><span class="pre">target</span></tt> , <tt class="docutils literal"><span class="pre">format</span></tt> ) on the currently set context.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.deleteTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.deleteTexture"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.deleteTexture()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">bindTexture</tt><big>(</big><em>fileName</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fileName</strong> &#8211; unicode</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLuint</span></tt></td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Calls QGLContext::bindTexture(<tt class="docutils literal"><span class="pre">fileName</span></tt> ) on the currently set context.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.deleteTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.deleteTexture"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.deleteTexture()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">bindTexture</tt><big>(</big><em>image</em>, <em>target</em>, <em>format</em>, <em>options</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> &#8211; <a class="reference internal" href="../QtGui/QImage.html#PySide.QtGui.QImage" title="PySide.QtGui.QImage"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QImage</span></tt></a></li>
<li><strong>target</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLenum</span></tt></li>
<li><strong>format</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLint</span></tt></li>
<li><strong>options</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLContext.BindOptions</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLuint</span></tt></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">bindTexture</tt><big>(</big><em>image</em><span class="optional">[</span>, <em>target=0x0DE1</em><span class="optional">[</span>, <em>format=0x1908</em><span class="optional">]</span><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> &#8211; <a class="reference internal" href="../QtGui/QImage.html#PySide.QtGui.QImage" title="PySide.QtGui.QImage"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QImage</span></tt></a></li>
<li><strong>target</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLenum</span></tt></li>
<li><strong>format</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLint</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLuint</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>Calls QGLContext:::bindTexture(<tt class="docutils literal"><span class="pre">image</span></tt> , <tt class="docutils literal"><span class="pre">target</span></tt> , <tt class="docutils literal"><span class="pre">format</span></tt> ) on the currently set context.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.deleteTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.deleteTexture"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.deleteTexture()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.colormap">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">colormap</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.colormap" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QGLColormap.html#PySide.QtOpenGL.QGLColormap" title="PySide.QtOpenGL.QGLColormap"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLColormap</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the colormap for this widget.</p>
<p>Usually it is only top-level widgets that can have different colormaps installed. Asking for the colormap of a child widget will return the colormap for the child&#8217;s top-level widget.</p>
<p>If no colormap has been set for this widget, the <a class="reference internal" href="QGLColormap.html#PySide.QtOpenGL.QGLColormap" title="PySide.QtOpenGL.QGLColormap"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLColormap</span></tt></a> returned will be empty.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setColormap" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setColormap"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.setColormap()</span></tt></a>  <a class="reference internal" href="QGLColormap.html#PySide.QtOpenGL.PySide.QtOpenGL.QGLColormap.isEmpty" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLColormap.isEmpty"><tt class="xref py py-meth docutils literal"><span class="pre">QGLColormap.isEmpty()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.context">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">context</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.context" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.QGLContext" title="PySide.QtOpenGL.QGLContext"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLContext</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the context of this widget.</p>
<p>It is possible that the context is not valid (see <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.isValid" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.isValid()</span></tt></a> ), for example, if the underlying hardware does not support the format attributes that were requested.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.convertToGLFormat">
<em class="property">static </em><tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">convertToGLFormat</tt><big>(</big><em>img</em><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.convertToGLFormat" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>img</strong> &#8211; <a class="reference internal" href="../QtGui/QImage.html#PySide.QtGui.QImage" title="PySide.QtGui.QImage"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QImage</span></tt></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../QtGui/QImage.html#PySide.QtGui.QImage" title="PySide.QtGui.QImage"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QImage</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Converts the image <tt class="docutils literal"><span class="pre">img</span></tt> into the unnamed format expected by OpenGL functions such as glTexImage2D(). The returned image is not usable as a <a class="reference internal" href="../QtGui/QImage.html#PySide.QtGui.QImage" title="PySide.QtGui.QImage"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QImage</span></tt></a> , but <tt class="xref py py-meth docutils literal"><span class="pre">QImage.width()</span></tt> , <tt class="xref py py-meth docutils literal"><span class="pre">QImage.height()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">QImage.bits()</span></tt> may be used with OpenGL. The GL format used is <tt class="docutils literal"><span class="pre">GL_RGBA</span></tt> .</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.deleteTexture">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">deleteTexture</tt><big>(</big><em>tx_id</em><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.deleteTexture" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tx_id</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLuint</span></tt></td>
</tr>
</tbody>
</table>
<p>Calls QGLContext::deleteTexture(<tt class="docutils literal"><span class="pre">id</span></tt> ) on the currently set context.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.bindTexture"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.bindTexture()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.doneCurrent">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">doneCurrent</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.doneCurrent" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes no GL context the current context. Normally, you do not need to call this function; <a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.QGLContext" title="PySide.QtOpenGL.QGLContext"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLContext</span></tt></a> calls it as necessary. However, it may be useful in multithreaded environments.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.doubleBuffer">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">doubleBuffer</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.doubleBuffer" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if the contained GL rendering context has double buffering; otherwise returns false.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QGLFormat.html#PySide.QtOpenGL.PySide.QtOpenGL.QGLFormat.doubleBuffer" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLFormat.doubleBuffer"><tt class="xref py py-meth docutils literal"><span class="pre">QGLFormat.doubleBuffer()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.drawTexture">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">drawTexture</tt><big>(</big><em>target</em>, <em>textureId</em><span class="optional">[</span>, <em>textureTarget=0x0DE1</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.drawTexture" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>target</strong> &#8211; <a class="reference internal" href="../QtCore/QRectF.html#PySide.QtCore.QRectF" title="PySide.QtCore.QRectF"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QRectF</span></tt></a></li>
<li><strong>textureId</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLuint</span></tt></li>
<li><strong>textureTarget</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLenum</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Calls the corresponding <a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.PySide.QtOpenGL.QGLContext.drawTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLContext.drawTexture"><tt class="xref py py-meth docutils literal"><span class="pre">QGLContext.drawTexture()</span></tt></a> with <tt class="docutils literal"><span class="pre">target</span></tt> , <tt class="docutils literal"><span class="pre">textureId</span></tt> , and <tt class="docutils literal"><span class="pre">textureTarget</span></tt> for this widget&#8217;s context.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">drawTexture</tt><big>(</big><em>point</em>, <em>textureId</em><span class="optional">[</span>, <em>textureTarget=0x0DE1</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>point</strong> &#8211; <a class="reference internal" href="../QtCore/QPointF.html#PySide.QtCore.QPointF" title="PySide.QtCore.QPointF"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QPointF</span></tt></a></li>
<li><strong>textureId</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLuint</span></tt></li>
<li><strong>textureTarget</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.GLenum</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Calls the corresponding <a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.PySide.QtOpenGL.QGLContext.drawTexture" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLContext.drawTexture"><tt class="xref py py-meth docutils literal"><span class="pre">QGLContext.drawTexture()</span></tt></a> with <tt class="docutils literal"><span class="pre">point</span></tt> , <tt class="docutils literal"><span class="pre">textureId</span></tt> , and <tt class="docutils literal"><span class="pre">textureTarget</span></tt> for this widget&#8217;s context.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.format">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">format</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.format" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QGLFormat.html#PySide.QtOpenGL.QGLFormat" title="PySide.QtOpenGL.QGLFormat"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLFormat</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the format of the contained GL rendering context.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.setFormat()</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.glDraw">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">glDraw</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.glDraw" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the virtual function <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintGL()</span></tt></a> .</p>
<p>The widget&#8217;s rendering context will become the current context and <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.initializeGL()</span></tt></a> will be called if it hasn&#8217;t already been called.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.glInit">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">glInit</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.glInit" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes OpenGL for this widget&#8217;s context. Calls the virtual function <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.initializeGL()</span></tt></a> .</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.grabFrameBuffer">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">grabFrameBuffer</tt><big>(</big><span class="optional">[</span><em>withAlpha=false</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.grabFrameBuffer" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>withAlpha</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../QtGui/QImage.html#PySide.QtGui.QImage" title="PySide.QtGui.QImage"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QImage</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns an image of the frame buffer. If <tt class="docutils literal"><span class="pre">withAlpha</span></tt> is true the alpha channel is included.</p>
<p>Depending on your hardware, you can explicitly select which color buffer to grab with a glReadBuffer() call before calling this function.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">initializeGL</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL" title="Permalink to this definition">¶</a></dt>
<dd><p>This virtual function is called once before the first call to <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintGL()</span></tt></a> or <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.resizeGL()</span></tt></a> , and then once whenever the widget has been assigned a new <a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.QGLContext" title="PySide.QtOpenGL.QGLContext"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLContext</span></tt></a> . Reimplement it in a subclass.</p>
<p>This function should set up any required OpenGL context rendering flags, defining display lists, etc.</p>
<p>There is no need to call <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.makeCurrent()</span></tt></a> because this has already been done when this function is called.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeOverlayGL">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">initializeOverlayGL</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeOverlayGL" title="Permalink to this definition">¶</a></dt>
<dd><p>This virtual function is used in the same manner as <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.initializeGL()</span></tt></a> except that it operates on the widget&#8217;s overlay context instead of the widget&#8217;s main context. This means that <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.initializeOverlayGL()</span></tt></a> is called once before the first call to <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintOverlayGL()</span></tt></a> or <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.resizeOverlayGL()</span></tt></a> . Reimplement it in a subclass.</p>
<p>This function should set up any required OpenGL context rendering flags, defining display lists, etc. for the overlay context.</p>
<p>There is no need to call <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeOverlayCurrent" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeOverlayCurrent"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.makeOverlayCurrent()</span></tt></a> because this has already been done when this function is called.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.isSharing">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">isSharing</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.isSharing" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if this widget&#8217;s GL context is shared with another GL context, otherwise false is returned. Context sharing might not be possible if the widgets use different formats.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.format" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.format"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.format()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.isValid">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">isValid</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.isValid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if the widget has a valid GL rendering context; otherwise returns false. A widget will be invalid if the system has no <a class="reference internal" href="QGLFormat.html#PySide.QtOpenGL.PySide.QtOpenGL.QGLFormat.hasOpenGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLFormat.hasOpenGL"><tt class="xref py py-meth docutils literal"><span class="pre">OpenGL</span> <span class="pre">support</span></tt></a> .</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">makeCurrent</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes this widget the current widget for OpenGL operations, i.e. makes the widget&#8217;s rendering context the current OpenGL rendering context.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeOverlayCurrent">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">makeOverlayCurrent</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeOverlayCurrent" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the overlay context of this widget current. Use this if you need to issue OpenGL commands to the overlay context outside of <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.initializeOverlayGL()</span></tt></a> , <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.resizeOverlayGL()</span></tt></a> , and <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintOverlayGL()</span></tt></a> .</p>
<p>Does nothing if this widget has no overlay.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.makeCurrent()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.overlayContext">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">overlayContext</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.overlayContext" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.QGLContext" title="PySide.QtOpenGL.QGLContext"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLContext</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the overlay context of this widget, or 0 if this widget has no overlay.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.context" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.context"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.context()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">paintGL</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="Permalink to this definition">¶</a></dt>
<dd><p>This virtual function is called whenever the widget needs to be painted. Reimplement it in a subclass.</p>
<p>There is no need to call <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.makeCurrent()</span></tt></a> because this has already been done when this function is called.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">paintOverlayGL</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL" title="Permalink to this definition">¶</a></dt>
<dd><p>This virtual function is used in the same manner as <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintGL()</span></tt></a> except that it operates on the widget&#8217;s overlay context instead of the widget&#8217;s main context. This means that <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintOverlayGL()</span></tt></a> is called whenever the widget&#8217;s overlay needs to be painted. Reimplement it in a subclass.</p>
<p>There is no need to call <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeOverlayCurrent" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeOverlayCurrent"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.makeOverlayCurrent()</span></tt></a> because this has already been done when this function is called.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglClearColor">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">qglClearColor</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglClearColor" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>c</strong> &#8211; <a class="reference internal" href="../QtGui/QColor.html#PySide.QtGui.QColor" title="PySide.QtGui.QColor"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QColor</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Convenience function for specifying the clearing color to OpenGL. Calls glClearColor (in RGBA mode) or glClearIndex (in color-index mode) with the color <tt class="docutils literal"><span class="pre">c</span></tt> . Applies to this widgets GL context.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglColor" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglColor"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.qglColor()</span></tt></a>  <a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.PySide.QtOpenGL.QGLContext.currentContext" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLContext.currentContext"><tt class="xref py py-meth docutils literal"><span class="pre">QGLContext.currentContext()</span></tt></a>  <a class="reference internal" href="../QtGui/QColor.html#PySide.QtGui.QColor" title="PySide.QtGui.QColor"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QColor</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglColor">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">qglColor</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglColor" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>c</strong> &#8211; <a class="reference internal" href="../QtGui/QColor.html#PySide.QtGui.QColor" title="PySide.QtGui.QColor"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QColor</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Convenience function for specifying a drawing color to OpenGL. Calls glColor4 (in RGBA mode) or glIndex (in color-index mode) with the color <tt class="docutils literal"><span class="pre">c</span></tt> . Applies to this widgets GL context.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function is not supported on OpenGL/ES 2.0 systems.</p>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglClearColor" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglClearColor"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.qglClearColor()</span></tt></a>  <a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.PySide.QtOpenGL.QGLContext.currentContext" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLContext.currentContext"><tt class="xref py py-meth docutils literal"><span class="pre">QGLContext.currentContext()</span></tt></a>  <a class="reference internal" href="../QtGui/QColor.html#PySide.QtGui.QColor" title="PySide.QtGui.QColor"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QColor</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.renderPixmap">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">renderPixmap</tt><big>(</big><span class="optional">[</span><em>w=0</em><span class="optional">[</span>, <em>h=0</em><span class="optional">[</span>, <em>useContext=false</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.renderPixmap" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>w</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
<li><strong>h</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
<li><strong>useContext</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="../QtGui/QPixmap.html#PySide.QtGui.QPixmap" title="PySide.QtGui.QPixmap"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QPixmap</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Renders the current scene on a pixmap and returns the pixmap.</p>
<p>You can use this method on both visible and invisible <a class="reference internal" href="#PySide.QtOpenGL.QGLWidget" title="PySide.QtOpenGL.QGLWidget"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget</span></tt></a> objects.</p>
<p>This method will create a pixmap and a temporary <a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.QGLContext" title="PySide.QtOpenGL.QGLContext"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLContext</span></tt></a> to render on the pixmap. It will then call <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.initializeGL()</span></tt></a> , <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.resizeGL()</span></tt></a> , and <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintGL()</span></tt></a> on this context. Finally, the widget&#8217;s original GL context is restored.</p>
<p>The size of the pixmap will be <tt class="docutils literal"><span class="pre">w</span></tt> pixels wide and <tt class="docutils literal"><span class="pre">h</span></tt> pixels high unless one of these parameters is 0 (the default), in which case the pixmap will have the same size as the widget.</p>
<p>If <tt class="docutils literal"><span class="pre">useContext</span></tt> is true, this method will try to be more efficient by using the existing GL context to render the pixmap. The default is false. Only use true if you understand the risks. Note that under Windows a temporary context has to be created and usage of the <em>useContext</em> parameter is not supported.</p>
<p>Overlays are not rendered onto the pixmap.</p>
<p>If the GL rendering context and the desktop have different bit depths, the result will most likely look surprising.</p>
<p>Note that the creation of display lists, modifications of the view frustum etc. should be done from within <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.initializeGL()</span></tt></a> . If this is not done, the temporary <a class="reference internal" href="QGLContext.html#PySide.QtOpenGL.QGLContext" title="PySide.QtOpenGL.QGLContext"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLContext</span></tt></a> will not be initialized properly, and the rendered pixmap may be incomplete/corrupted.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.renderText">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">renderText</tt><big>(</big><em>x</em>, <em>y</em>, <em>str</em><span class="optional">[</span>, <em>fnt=QFont()</em><span class="optional">[</span>, <em>listBase=2000</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.renderText" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
<li><strong>y</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
<li><strong>str</strong> &#8211; unicode</li>
<li><strong>fnt</strong> &#8211; <a class="reference internal" href="../QtGui/QFont.html#PySide.QtGui.QFont" title="PySide.QtGui.QFont"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QFont</span></tt></a></li>
<li><strong>listBase</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Renders the string <tt class="docutils literal"><span class="pre">str</span></tt> into the GL context of this widget.</p>
<p><tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> are specified in window coordinates, with the origin in the upper left-hand corner of the window. If <tt class="docutils literal"><span class="pre">font</span></tt> is not specified, the currently set application font will be used to render the string. To change the color of the rendered text you can use the glColor() call (or the <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglColor" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.qglColor"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.qglColor()</span></tt></a> convenience function), just before the <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.renderText" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.renderText"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.renderText()</span></tt></a> call.</p>
<p>The <tt class="docutils literal"><span class="pre">listBase</span></tt> parameter is obsolete and will be removed in a future version of Qt.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function clears the stencil buffer.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function is not supported on OpenGL/ES systems.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function temporarily disables depth-testing when the text is drawn.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function can only be used inside a <tt class="xref py py-meth docutils literal"><span class="pre">QPainter.beginNativePainting()</span></tt> / <tt class="xref py py-meth docutils literal"><span class="pre">QPainter.endNativePainting()</span></tt> block if the default OpenGL paint engine is <tt class="xref py py-attr docutils literal"><span class="pre">QPaintEngine.OpenGL</span></tt> . To make <tt class="xref py py-attr docutils literal"><span class="pre">QPaintEngine.OpenGL</span></tt> the default GL engine, call QGL::setPreferredPaintEngine( <tt class="xref py py-attr docutils literal"><span class="pre">QPaintEngine.OpenGL</span></tt> ) before the <a class="reference internal" href="../QtGui/QApplication.html#PySide.QtGui.QApplication" title="PySide.QtGui.QApplication"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QApplication</span></tt></a> constructor.</p>
</div>
<p><em class="xref std std-ref">Overpaint</em> with <tt class="xref py py-meth docutils literal"><span class="pre">QPainter.drawText()</span></tt> instead.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">renderText</tt><big>(</big><em>x</em>, <em>y</em>, <em>z</em>, <em>str</em><span class="optional">[</span>, <em>fnt=QFont()</em><span class="optional">[</span>, <em>listBase=2000</em><span class="optional">]</span><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.double</span></tt></li>
<li><strong>y</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.double</span></tt></li>
<li><strong>z</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.double</span></tt></li>
<li><strong>str</strong> &#8211; unicode</li>
<li><strong>fnt</strong> &#8211; <a class="reference internal" href="../QtGui/QFont.html#PySide.QtGui.QFont" title="PySide.QtGui.QFont"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtGui.QFont</span></tt></a></li>
<li><strong>listBase</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p><tt class="docutils literal"><span class="pre">x</span></tt> , <tt class="docutils literal"><span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">z</span></tt> are specified in scene or object coordinates relative to the currently set projection and model matrices. This can be useful if you want to annotate models with text labels and have the labels move with the model as it is rotated etc.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function is not supported on OpenGL/ES systems.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If depth testing is enabled before this function is called, then the drawn text will be depth-tested against the models that have already been drawn in the scene. Use <tt class="docutils literal"><span class="pre">glDisable(GL_DEPTH_TEST)</span></tt> before calling this function to annotate the models without depth-testing the text.</p>
</div>
<p><em class="xref std std-ref">Overpaint</em> with <tt class="xref py py-meth docutils literal"><span class="pre">QPainter.drawText()</span></tt> instead.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">resizeGL</tt><big>(</big><em>w</em>, <em>h</em><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeGL" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>w</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
<li><strong>h</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This virtual function is called whenever the widget has been resized. The new size is passed in <tt class="docutils literal"><span class="pre">width</span></tt> and <tt class="docutils literal"><span class="pre">height</span></tt> . Reimplement it in a subclass.</p>
<p>There is no need to call <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeCurrent"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.makeCurrent()</span></tt></a> because this has already been done when this function is called.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeOverlayGL">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">resizeOverlayGL</tt><big>(</big><em>w</em>, <em>h</em><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeOverlayGL" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>w</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
<li><strong>h</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This virtual function is used in the same manner as <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintGL()</span></tt></a> except that it operates on the widget&#8217;s overlay context instead of the widget&#8217;s main context. This means that <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.resizeOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.resizeOverlayGL()</span></tt></a> is called whenever the widget has been resized. The new size is passed in <tt class="docutils literal"><span class="pre">width</span></tt> and <tt class="docutils literal"><span class="pre">height</span></tt> . Reimplement it in a subclass.</p>
<p>There is no need to call <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeOverlayCurrent" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.makeOverlayCurrent"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.makeOverlayCurrent()</span></tt></a> because this has already been done when this function is called.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setAutoBufferSwap">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">setAutoBufferSwap</tt><big>(</big><em>on</em><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setAutoBufferSwap" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>on</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>If <tt class="docutils literal"><span class="pre">on</span></tt> is true automatic GL buffer swapping is switched on; otherwise it is switched off.</p>
<p>If <tt class="docutils literal"><span class="pre">on</span></tt> is true and the widget is using a double-buffered format, the background and foreground GL buffers will automatically be swapped after each <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintGL()</span></tt></a> call.</p>
<p>The buffer auto-swapping is on by default.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.autoBufferSwap" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.autoBufferSwap"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.autoBufferSwap()</span></tt></a>  <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.doubleBuffer" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.doubleBuffer"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.doubleBuffer()</span></tt></a>  <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.swapBuffers" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.swapBuffers"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.swapBuffers()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setColormap">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">setColormap</tt><big>(</big><em>map</em><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setColormap" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>map</strong> &#8211; <a class="reference internal" href="QGLColormap.html#PySide.QtOpenGL.QGLColormap" title="PySide.QtOpenGL.QGLColormap"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtOpenGL.QGLColormap</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Set the colormap for this widget to <tt class="docutils literal"><span class="pre">cmap</span></tt> . Usually it is only top-level widgets that can have colormaps installed.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.colormap" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.colormap"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.colormap()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.swapBuffers">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">swapBuffers</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.swapBuffers" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps the screen contents with an off-screen buffer. This only works if the widget&#8217;s format specifies double buffer mode.</p>
<p>Normally, there is no need to explicitly call this function because it is done automatically after each widget repaint, i.e. each time after <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintGL()</span></tt></a> has been executed.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.doubleBuffer" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.doubleBuffer"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.doubleBuffer()</span></tt></a>  <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setAutoBufferSwap" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.setAutoBufferSwap"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.setAutoBufferSwap()</span></tt></a>  <a class="reference internal" href="QGLFormat.html#PySide.QtOpenGL.PySide.QtOpenGL.QGLFormat.setDoubleBuffer" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLFormat.setDoubleBuffer"><tt class="xref py py-meth docutils literal"><span class="pre">QGLFormat.setDoubleBuffer()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.updateGL">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">updateGL</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.updateGL" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the widget by calling <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.glDraw" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.glDraw"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.glDraw()</span></tt></a> .</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.updateOverlayGL">
<tt class="descclassname">PySide.QtOpenGL.QGLWidget.</tt><tt class="descname">updateOverlayGL</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.updateOverlayGL" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the widget&#8217;s overlay (if any). Will cause the virtual function <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.paintOverlayGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.paintOverlayGL()</span></tt></a> to be executed.</p>
<p>The widget&#8217;s rendering context will become the current context and <a class="reference internal" href="#PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL" title="PySide.QtOpenGL.PySide.QtOpenGL.QGLWidget.initializeGL"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtOpenGL.QGLWidget.initializeGL()</span></tt></a> will be called if it hasn&#8217;t already been called.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    <a href="http://www.indt.org.br"><img src="../../_static/logo_indt.jpg" alt="Indt" border="0" /></a>
    <a href="http://www.openbossa.org"><img src="../../_static/logo_openbossa.png" alt="Openbossa" border="0" /></a>
    <a href="http://qt.nokia.com/"><img src="../../_static/logo_qt.png" alt="Qt" border="0" /></a>
    <a href="http://www.python.org"><img src="../../_static/logo_python.jpg" alt="Python" border="0" /></a>
    </div>
</div>
  </body>
</html>