.. module:: PySide.QtScript
.. _QScriptEngine:

QScriptEngine
*************

.. inheritance-diagram:: QScriptEngine
    :parts: 2

Synopsis
--------

Functions
^^^^^^^^^
.. container:: function_list

*    def :meth:`abortEvaluation<PySide.QtScript.QScriptEngine.abortEvaluation>` ([result=QScriptValue()])
*    def :meth:`agent<PySide.QtScript.QScriptEngine.agent>` ()
*    def :meth:`availableExtensions<PySide.QtScript.QScriptEngine.availableExtensions>` ()
*    def :meth:`canEvaluate<PySide.QtScript.QScriptEngine.canEvaluate>` (program)
*    def :meth:`clearExceptions<PySide.QtScript.QScriptEngine.clearExceptions>` ()
*    def :meth:`collectGarbage<PySide.QtScript.QScriptEngine.collectGarbage>` ()
*    def :meth:`convert<PySide.QtScript.QScriptEngine.convert>` (value, type, ptr)
*    def :meth:`create<PySide.QtScript.QScriptEngine.create>` (type, ptr)
*    def :meth:`currentContext<PySide.QtScript.QScriptEngine.currentContext>` ()
*    def :meth:`defaultPrototype<PySide.QtScript.QScriptEngine.defaultPrototype>` (metaTypeId)
*    def :meth:`evaluate<PySide.QtScript.QScriptEngine.evaluate>` (program)
*    def :meth:`evaluate<PySide.QtScript.QScriptEngine.evaluate>` (program[, fileName=""[, lineNumber=1]])
*    def :meth:`globalObject<PySide.QtScript.QScriptEngine.globalObject>` ()
*    def :meth:`hasUncaughtException<PySide.QtScript.QScriptEngine.hasUncaughtException>` ()
*    def :meth:`importExtension<PySide.QtScript.QScriptEngine.importExtension>` (extension)
*    def :meth:`importedExtensions<PySide.QtScript.QScriptEngine.importedExtensions>` ()
*    def :meth:`installTranslatorFunctions<PySide.QtScript.QScriptEngine.installTranslatorFunctions>` ([object=QScriptValue()])
*    def :meth:`isEvaluating<PySide.QtScript.QScriptEngine.isEvaluating>` ()
*    def :meth:`newActivationObject<PySide.QtScript.QScriptEngine.newActivationObject>` ()
*    def :meth:`newArray<PySide.QtScript.QScriptEngine.newArray>` ([length=0])
*    def :meth:`newDate<PySide.QtScript.QScriptEngine.newDate>` (value)
*    def :meth:`newDate<PySide.QtScript.QScriptEngine.newDate>` (value)
*    def :meth:`newObject<PySide.QtScript.QScriptEngine.newObject>` ()
*    def :meth:`newObject<PySide.QtScript.QScriptEngine.newObject>` (scriptClass[, data=QScriptValue()])
*    def :meth:`newQMetaObject<PySide.QtScript.QScriptEngine.newQMetaObject>` (metaObject[, ctor=QScriptValue()])
*    def :meth:`newQObject<PySide.QtScript.QScriptEngine.newQObject>` (object[, ownership=QtOwnership[, options=0]])
*    def :meth:`newQObject<PySide.QtScript.QScriptEngine.newQObject>` (scriptObject, qtObject[, ownership=QtOwnership[, options=0]])
*    def :meth:`newRegExp<PySide.QtScript.QScriptEngine.newRegExp>` (pattern, flags)
*    def :meth:`newRegExp<PySide.QtScript.QScriptEngine.newRegExp>` (regexp)
*    def :meth:`newVariant<PySide.QtScript.QScriptEngine.newVariant>` (object, value)
*    def :meth:`newVariant<PySide.QtScript.QScriptEngine.newVariant>` (value)
*    def :meth:`nullValue<PySide.QtScript.QScriptEngine.nullValue>` ()
*    def :meth:`objectById<PySide.QtScript.QScriptEngine.objectById>` (id)
*    def :meth:`popContext<PySide.QtScript.QScriptEngine.popContext>` ()
*    def :meth:`processEventsInterval<PySide.QtScript.QScriptEngine.processEventsInterval>` ()
*    def :meth:`pushContext<PySide.QtScript.QScriptEngine.pushContext>` ()
*    def :meth:`reportAdditionalMemoryCost<PySide.QtScript.QScriptEngine.reportAdditionalMemoryCost>` (size)
*    def :meth:`setAgent<PySide.QtScript.QScriptEngine.setAgent>` (agent)
*    def :meth:`setDefaultPrototype<PySide.QtScript.QScriptEngine.setDefaultPrototype>` (metaTypeId, prototype)
*    def :meth:`setGlobalObject<PySide.QtScript.QScriptEngine.setGlobalObject>` (object)
*    def :meth:`setProcessEventsInterval<PySide.QtScript.QScriptEngine.setProcessEventsInterval>` (interval)
*    def :meth:`toObject<PySide.QtScript.QScriptEngine.toObject>` (value)
*    def :meth:`toStringHandle<PySide.QtScript.QScriptEngine.toStringHandle>` (str)
*    def :meth:`uncaughtException<PySide.QtScript.QScriptEngine.uncaughtException>` ()
*    def :meth:`uncaughtExceptionBacktrace<PySide.QtScript.QScriptEngine.uncaughtExceptionBacktrace>` ()
*    def :meth:`uncaughtExceptionLineNumber<PySide.QtScript.QScriptEngine.uncaughtExceptionLineNumber>` ()
*    def :meth:`undefinedValue<PySide.QtScript.QScriptEngine.undefinedValue>` ()


Signals
^^^^^^^
.. container:: function_list

*    def :meth:`signalHandlerException<PySide.QtScript.QScriptEngine.signalHandlerException>` (exception)


Static functions
^^^^^^^^^^^^^^^^
.. container:: function_list

*    def :meth:`convertV2<PySide.QtScript.QScriptEngine.convertV2>` (value, type, ptr)


Detailed Description
--------------------



    The :class:`PySide.QtScript.QScriptEngine` class provides an environment for evaluating Qt Script code.

    See the :ref:`QtScript` documentation for information about the Qt Script language, and how to get started with scripting your C++ application.

    .. _PySide.QtScript.QScriptEngine_evaluating-scripts:



Evaluating Scripts
^^^^^^^^^^^^^^^^^^

    Use :meth:`PySide.QtScript.QScriptEngine.evaluate` to evaluate script code; this is the C++ equivalent of the built-in script function ``eval()`` .

    ::

        myEngine = QScriptEngine()
        three = myEngine.evaluate("1 + 2")


    :meth:`PySide.QtScript.QScriptEngine.evaluate` returns a :class:`PySide.QtScript.QScriptValue` that holds the result of the evaluation. The :class:`PySide.QtScript.QScriptValue` class provides functions for converting the result to various C++ types (e.g. :meth:`QScriptValue.toString()<PySide.QtScript.QScriptValue.toString>` and :meth:`QScriptValue.toNumber()<PySide.QtScript.QScriptValue.toNumber>` ).

    The following code snippet shows how a script function can be defined and then invoked from C++ using :meth:`QScriptValue.call()<PySide.QtScript.QScriptValue.call>` :

    ::

        fun = myEngine.evaluate("function(a, b) { return a + b }");
        args = QScriptValueList()
        args << 1 << 2
        threeAgain = fun.call(QScriptValue(), args)


    As can be seen from the above snippets, a script is provided to the engine in the form of a string. One common way of loading scripts is by reading the contents of a file and passing it to :meth:`PySide.QtScript.QScriptEngine.evaluate` :

    ::

        fileName = "helloworld.qs"
        scriptFile = QFile(fileName)
        if !scriptFile.open(QIODevice.ReadOnly):
            # handle error
        stream = QTextStream(scriptFile)
        contents = stream.readAll()
        scriptFile.close()
        myEngine.evaluate(contents, fileName)


    Here we pass the name of the file as the second argument to :meth:`PySide.QtScript.QScriptEngine.evaluate` . This does not affect evaluation in any way; the second argument is a general-purpose string that is used to identify the script for debugging purposes (for example, our filename will now show up in any :meth:`PySide.QtScript.QScriptEngine.uncaughtExceptionBacktrace` involving the script).

    .. _PySide.QtScript.QScriptEngine_engine-configuration:



Engine Configuration
^^^^^^^^^^^^^^^^^^^^

    The :meth:`PySide.QtScript.QScriptEngine.globalObject` function returns the **Global Object** associated with the script engine. Properties of the Global Object are accessible from any script code (i.e. they are global variables). Typically, before evaluating "user" scripts, you will want to configure a script engine by adding one or more properties to the Global Object:

    ::

        myEngine.globalObject().setProperty("myNumber", 123)
        ...
        myNumberPlusOne = myEngine.evaluate("myNumber + 1")


    Adding custom properties to the scripting environment is one of the standard means of providing a scripting API that is specific to your application. Usually these custom properties are objects created by the :meth:`PySide.QtScript.QScriptEngine.newQObject` or :meth:`PySide.QtScript.QScriptEngine.newObject` functions, or constructor functions created by :meth:`~PySide.QtScript.QScriptEngine.newFunction` .

    .. _PySide.QtScript.QScriptEngine_script-exceptions:



Script Exceptions
^^^^^^^^^^^^^^^^^

    :meth:`PySide.QtScript.QScriptEngine.evaluate` can throw a script exception (e.g. due to a syntax error); in that case, the return value is the value that was thrown (typically an ``Error`` object). You can check whether the evaluation caused an exception by calling :meth:`PySide.QtScript.QScriptEngine.hasUncaughtException` . In that case, you can call :meth:`~PySide.QtScript.QScriptEngine.toString` on the error object to obtain an error message. The current uncaught exception is also available through :meth:`PySide.QtScript.QScriptEngine.uncaughtException` . Calling :meth:`PySide.QtScript.QScriptEngine.clearExceptions` will cause any uncaught exceptions to be cleared.

    ::

        result = myEngine.evaluate(...)
        if myEngine.hasUncaughtException():
            line = myEngine.uncaughtExceptionLineNumber()
            print "uncaught exception at line", line, ":", result.toString()


    The :meth:`~PySide.QtScript.QScriptEngine.checkSyntax` function can be used to determine whether code can be usefully passed to :meth:`PySide.QtScript.QScriptEngine.evaluate` .

    .. _PySide.QtScript.QScriptEngine_script-object-creation:



Script Object Creation
^^^^^^^^^^^^^^^^^^^^^^

    Use :meth:`PySide.QtScript.QScriptEngine.newObject` to create a standard Qt Script object; this is the C++ equivalent of the script statement ``new Object()`` . You can use the object-specific functionality in :class:`PySide.QtScript.QScriptValue` to manipulate the script object (e.g. :meth:`QScriptValue.setProperty()<PySide.QtScript.QScriptValue.setProperty>` ). Similarly, use :meth:`PySide.QtScript.QScriptEngine.newArray` to create a Qt Script array object. Use :meth:`PySide.QtScript.QScriptEngine.newDate` to create a ``Date`` object, and :meth:`PySide.QtScript.QScriptEngine.newRegExp` to create a ``RegExp`` object.

    .. _PySide.QtScript.QScriptEngine_qobject-integration:



QObject Integration
^^^^^^^^^^^^^^^^^^^

    Use :meth:`PySide.QtScript.QScriptEngine.newQObject` to wrap a :class:`PySide.QtCore.QObject` (or subclass) pointer. :meth:`PySide.QtScript.QScriptEngine.newQObject` returns a proxy script object; properties, children, and signals and slots of the :class:`PySide.QtCore.QObject` are available as properties of the proxy object. No binding code is needed because it is done dynamically using the Qt meta object system.

    ::

        button = QPushButton()
        QScriptValue scriptButton = myEngine.QObject(button)
        myEngine.globalObject().setProperty("button", scriptButton)

        myEngine.evaluate("button.checkable = True")

        print scriptButton.property("checkable").toBoolean()
        scriptButton.property("show").call() # call the show() slot


    Use :meth:`~PySide.QtScript.QScriptEngine.qScriptConnect` to connect a C++ signal to a script function; this is the Qt Script equivalent of :meth:`QObject.connect()<PySide.QtCore.QObject.connect>` . When a script function is invoked in response to a C++ signal, it can cause a script exception; you can connect to the :meth:`PySide.QtScript.QScriptEngine.signalHandlerException` signal to catch such an exception.

    Use :meth:`PySide.QtScript.QScriptEngine.newQMetaObject` to wrap a :class:`PySide.QtCore.QMetaObject` ; this gives you a "script representation" of a :class:`PySide.QtCore.QObject` -based class. :meth:`PySide.QtScript.QScriptEngine.newQMetaObject` returns a proxy script object; enum values of the class are available as properties of the proxy object. You can also specify a function that will be used to construct objects of the class (e.g. when the constructor is invoked from a script). For classes that have a "standard" Qt constructor, Qt Script can provide a default script constructor for you; see :meth:`~PySide.QtScript.QScriptEngine.scriptValueFromQMetaObject` .

    See the :ref:`QtScript` documentation for more information on the :class:`PySide.QtCore.QObject` integration.

    .. _PySide.QtScript.QScriptEngine_support-for-custom-c-types:



Support for Custom C++ Types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Use :meth:`PySide.QtScript.QScriptEngine.newVariant` to wrap a :class:`PySide.QtCore.QVariant` . This can be used to store values of custom (non- :class:`PySide.QtCore.QObject` ) C++ types that have been registered with the Qt meta-type system. To make such types scriptable, you typically associate a prototype (delegate) object with the C++ type by calling :meth:`PySide.QtScript.QScriptEngine.setDefaultPrototype` ; the prototype object defines the scripting API for the C++ type. Unlike the :class:`PySide.QtCore.QObject` integration, there is no automatic binding possible here; i.e. you have to create the scripting API yourself, for example by using the :class:`PySide.QtScript.QScriptable` class.

    Use :meth:`~PySide.QtScript.QScriptEngine.fromScriptValue` to cast from a :class:`PySide.QtScript.QScriptValue` to another type, and :meth:`~PySide.QtScript.QScriptEngine.toScriptValue` to create a :class:`PySide.QtScript.QScriptValue` from another value. You can specify how the conversion of C++ types is to be performed with :meth:`~PySide.QtScript.QScriptEngine.qScriptRegisterMetaType` and :meth:`~PySide.QtScript.QScriptEngine.qScriptRegisterSequenceMetaType` . By default, Qt Script will use :class:`PySide.QtCore.QVariant` to store values of custom types.

    .. _PySide.QtScript.QScriptEngine_importing-extensions:



Importing Extensions
^^^^^^^^^^^^^^^^^^^^

    Use :meth:`PySide.QtScript.QScriptEngine.importExtension` to import plugin-based extensions into the engine. Call :meth:`PySide.QtScript.QScriptEngine.availableExtensions` to obtain a list naming all the available extensions, and :meth:`PySide.QtScript.QScriptEngine.importedExtensions` to obtain a list naming only those extensions that have been imported.

    Call :meth:`PySide.QtScript.QScriptEngine.pushContext` to open up a new variable scope, and :meth:`PySide.QtScript.QScriptEngine.popContext` to close the current scope. This is useful if you are implementing an extension that evaluates script code containing temporary variable definitions (e.g. ``var foo = 123;`` ) that are safe to discard when evaluation has completed.

    .. _PySide.QtScript.QScriptEngine_native-functions:



Native Functions
^^^^^^^^^^^^^^^^

    Use :meth:`~PySide.QtScript.QScriptEngine.newFunction` to wrap native (C++) functions, including constructors for your own custom types, so that these can be invoked from script code. Such functions must have the signature :class:`QScriptEngine.FunctionSignature<~PySide.QtScript.QScriptEngine.FunctionSignature>` . You may then pass the function as argument to :meth:`~PySide.QtScript.QScriptEngine.newFunction` . Here is an example of a function that returns the sum of its first two arguments:

    ::

        def myAdd(context, engine):
           a = context.argument(0)
           b = context.argument(1)
           return a.toNumber() + b.toNumber()


    To expose this function to script code, you can set it as a property of the Global Object:

    ::

        fun = myEngine.Function(myAdd)
        myEngine.globalObject().setProperty("myAdd", fun)


    Once this is done, script code can call your function in the exact same manner as a "normal" script function:

    ::

        result = myEngine.evaluate("myAdd(myNumber, 1)")


    .. _PySide.QtScript.QScriptEngine_long-running-scripts:



Long-running Scripts
^^^^^^^^^^^^^^^^^^^^

    If you need to evaluate possibly long-running scripts from the main (GUI) thread, you should first call :meth:`PySide.QtScript.QScriptEngine.setProcessEventsInterval` to make sure that the GUI stays responsive. You can abort a currently running script by calling :meth:`PySide.QtScript.QScriptEngine.abortEvaluation` . You can determine whether an engine is currently running a script by calling :meth:`PySide.QtScript.QScriptEngine.isEvaluating` .

    .. _PySide.QtScript.QScriptEngine_garbage-collection:



Garbage Collection
^^^^^^^^^^^^^^^^^^

    Qt Script objects may be garbage collected when they are no longer referenced. There is no guarantee as to when automatic garbage collection will take place.

    The :meth:`PySide.QtScript.QScriptEngine.collectGarbage` function can be called to explicitly request garbage collection.

    The :meth:`PySide.QtScript.QScriptEngine.reportAdditionalMemoryCost` function can be called to indicate that a Qt Script object occupies memory that isn't managed by the scripting environment. Reporting the additional cost makes it more likely that the garbage collector will be triggered. This can be useful, for example, when many custom, native Qt Script objects are allocated.

    .. _PySide.QtScript.QScriptEngine_core-debugging-tracing-facilities:



Core Debugging/Tracing Facilities
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Since Qt 4.4, you can be notified of events pertaining to script execution (e.g. script function calls and statement execution) through the :class:`PySide.QtScript.QScriptEngineAgent` interface; see the :meth:`PySide.QtScript.QScriptEngine.setAgent` function. This can be used to implement debugging and profiling of a :class:`PySide.QtScript.QScriptEngine` .

    .. seealso::  :class:`PySide.QtScript.QScriptValue`  :class:`PySide.QtScript.QScriptContext`  :class:`PySide.QtScript.QScriptEngineAgent` 

.. class:: QScriptEngine()
           QScriptEngine(parent)

    :param parent: :class:`PySide.QtCore.QObject`

    Constructs a :class:`PySide.QtScript.QScriptEngine` object.

    The :meth:`PySide.QtScript.QScriptEngine.globalObject` is initialized to have properties as described in :ref:`ECMA-262<http://www.ecma-international.org/publications/standards/Ecma-262.htm>` , Section 15.1.


    Constructs a :class:`PySide.QtScript.QScriptEngine` object with the given ``parent`` .

    The :meth:`PySide.QtScript.QScriptEngine.globalObject` is initialized to have properties as described in :ref:`ECMA-262<http://www.ecma-international.org/publications/standards/Ecma-262.htm>` , Section 15.1.


.. attribute:: PySide.QtScript.QScriptEngine.ValueOwnership

    This enum specifies the ownership when wrapping a C++ value, e.g. by using :meth:`PySide.QtScript.QScriptEngine.newQObject` .

    +-----------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Constant                     |Description                                                                                                                                                                                                                                                  |
    +=============================+=============================================================================================================================================================================================================================================================+
    |QScriptEngine.QtOwnership    |The standard Qt ownership rules apply, i.e. the associated object will never be explicitly deleted by the script engine. This is the default. ( :class:`PySide.QtCore.QObject` ownership is explained in :ref:`Object Trees & Ownership<objecttrees.html>` .)|
    +-----------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |QScriptEngine.ScriptOwnership|The value is owned by the script environment. The associated data will be deleted when appropriate (i.e. after the garbage collector has discovered that there are no more live references to the value).                                                    |
    +-----------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |QScriptEngine.AutoOwnership  |If the associated object has a parent, the Qt ownership rules apply ( :attr:`QtOwnership<QScriptEngine.ValueOwnership>` ); otherwise, the object is owned by the script environment ( :attr:`ScriptOwnership<QScriptEngine.ValueOwnership>` ).               |
    +-----------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


.. attribute:: PySide.QtScript.QScriptEngine.QObjectWrapOption

    These flags specify options when wrapping a :class:`PySide.QtCore.QObject` pointer with :meth:`PySide.QtScript.QScriptEngine.newQObject` .

    +-----------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |Constant                                 |Description                                                                                                                                                                    |
    +=========================================+===============================================================================================================================================================================+
    |QScriptEngine.ExcludeChildObjects        |The script object will not expose child objects as properties.                                                                                                                 |
    +-----------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |QScriptEngine.ExcludeSuperClassMethods   |The script object will not expose signals and slots inherited from the superclass.                                                                                             |
    +-----------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |QScriptEngine.ExcludeSuperClassProperties|The script object will not expose properties inherited from the superclass.                                                                                                    |
    +-----------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |QScriptEngine.ExcludeSuperClassContents  |Shorthand form for :attr:`ExcludeSuperClassMethods<QScriptEngine.QObjectWrapOption>` | :attr:`ExcludeSuperClassProperties<QScriptEngine.QObjectWrapOption>`                    |
    +-----------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |QScriptEngine.ExcludeDeleteLater         |The script object will not expose the :meth:`QObject.deleteLater()<PySide.QtCore.QObject.deleteLater>` slot.                                                                   |
    +-----------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |QScriptEngine.ExcludeSlots               |The script object will not expose the :class:`PySide.QtCore.QObject` 's slots.                                                                                                 |
    +-----------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |QScriptEngine.AutoCreateDynamicProperties|Properties that don't already exist in the :class:`PySide.QtCore.QObject` will be created as dynamic properties of that object, rather than as properties of the script object.|
    +-----------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |QScriptEngine.PreferExistingWrapperObject|If a wrapper object with the requested configuration already exists, return that object.                                                                                       |
    +-----------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    |QScriptEngine.SkipMethodsInEnumeration   |Don't include methods (signals and slots) when enumerating the object's properties.                                                                                            |
    +-----------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


.. method:: PySide.QtScript.QScriptEngine.abortEvaluation([result=QScriptValue()])


    :param result: :class:`PySide.QtScript.QScriptValue`




    Aborts any script evaluation currently taking place in this engine. The given ``result`` is passed back as the result of the evaluation (i.e. it is returned from the call to :meth:`PySide.QtScript.QScriptEngine.evaluate` being aborted).

    If the engine isn't evaluating a script (i.e. :meth:`PySide.QtScript.QScriptEngine.isEvaluating` returns false), this function does nothing.

    Call this function if you need to abort a running script for some reason, e.g. when you have detected that the script has been running for several seconds without completing.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.evaluate`  :meth:`PySide.QtScript.QScriptEngine.isEvaluating`  :meth:`PySide.QtScript.QScriptEngine.setProcessEventsInterval` 


.. method:: PySide.QtScript.QScriptEngine.agent()


    :rtype: :class:`PySide.QtScript.QScriptEngineAgent`




    Returns the agent currently installed on this engine, or 0 if no agent is installed.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.setAgent` 


.. method:: PySide.QtScript.QScriptEngine.availableExtensions()


    :rtype: list of strings




    Returns a list naming the available extensions that can be imported using the :meth:`PySide.QtScript.QScriptEngine.importExtension` function. This list includes extensions that have been imported.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.importExtension`  :meth:`PySide.QtScript.QScriptEngine.importedExtensions` 


.. method:: PySide.QtScript.QScriptEngine.canEvaluate(program)


    :param program: unicode
    :rtype: :class:`PySide.QtCore.bool`




    Returns true if ``program`` can be evaluated; i.e. the code is sufficient to determine whether it appears to be a syntactically correct program, or contains a syntax error.

    This function returns false if ``program`` is incomplete; i.e. the input is syntactically correct up to the point where the input is terminated.

    Note that this function only does a static check of ``program`` ; e.g. it does not check whether references to variables are valid, and so on.

    A typical usage of :meth:`PySide.QtScript.QScriptEngine.canEvaluate` is to implement an interactive interpreter for :ref:`QtScript` . The user is repeatedly queried for individual lines of code; the lines are concatened internally, and only when :meth:`PySide.QtScript.QScriptEngine.canEvaluate` returns true for the resulting program is it passed to :meth:`PySide.QtScript.QScriptEngine.evaluate` .

    The following are some examples to illustrate the behavior of :meth:`PySide.QtScript.QScriptEngine.canEvaluate` . (Note that all example inputs are assumed to have an explicit newline as their last character, since otherwise the :ref:`QtScript` parser would automatically insert a semi-colon character at the end of the input, and this could cause :meth:`PySide.QtScript.QScriptEngine.canEvaluate` to produce different results.)

    Given the input

    ::

        if hello && world:
            print("hello world")


    :meth:`PySide.QtScript.QScriptEngine.canEvaluate` will return true, since the program appears to be complete.

    Given the input

    ::

        if hello &&


    :meth:`PySide.QtScript.QScriptEngine.canEvaluate` will return false, since the if-statement is not complete, but is syntactically correct so far.

    Given the input

    ::

        0 = 0


    :meth:`PySide.QtScript.QScriptEngine.canEvaluate` will return true, but :meth:`PySide.QtScript.QScriptEngine.evaluate` will throw a SyntaxError given the same input.

    Given the input

    ::

        ./test.js


    :meth:`PySide.QtScript.QScriptEngine.canEvaluate` will return true, even though the code is clearly not syntactically valid :ref:`QtScript` code. :meth:`PySide.QtScript.QScriptEngine.evaluate` will throw a SyntaxError when this code is evaluated.

    Given the input

    ::

        foo["bar"]


    :meth:`PySide.QtScript.QScriptEngine.canEvaluate` will return true, but :meth:`PySide.QtScript.QScriptEngine.evaluate` will throw a ReferenceError if ``foo`` is not defined in the script environment.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.evaluate`  :meth:`~PySide.QtScript.QScriptEngine.checkSyntax` 


.. method:: PySide.QtScript.QScriptEngine.clearExceptions()






    Clears any uncaught exceptions in this engine.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.hasUncaughtException` 


.. method:: PySide.QtScript.QScriptEngine.collectGarbage()






    Runs the garbage collector.

    The garbage collector will attempt to reclaim memory by locating and disposing of objects that are no longer reachable in the script environment.

    Normally you don't need to call this function; the garbage collector will automatically be invoked when the :class:`PySide.QtScript.QScriptEngine` decides that it's wise to do so (i.e. when a certain number of new objects have been created). However, you can call this function to explicitly request that garbage collection should be performed as soon as possible.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.reportAdditionalMemoryCost` 


.. method:: PySide.QtScript.QScriptEngine.convert(value, type, ptr)


    :param value: :class:`PySide.QtScript.QScriptValue`
    :param type: :class:`PySide.QtCore.int`
    :param ptr: :class:`void`
    :rtype: :class:`PySide.QtCore.bool`






.. staticmethod:: PySide.QtScript.QScriptEngine.convertV2(value, type, ptr)


    :param value: :class:`PySide.QtScript.QScriptValue`
    :param type: :class:`PySide.QtCore.int`
    :param ptr: :class:`void`
    :rtype: :class:`PySide.QtCore.bool`






.. method:: PySide.QtScript.QScriptEngine.create(type, ptr)


    :param type: :class:`PySide.QtCore.int`
    :param ptr: :class:`void`
    :rtype: :class:`PySide.QtScript.QScriptValue`






.. method:: PySide.QtScript.QScriptEngine.currentContext()


    :rtype: :class:`PySide.QtScript.QScriptContext`




    Returns the current context.

    The current context is typically accessed to retrieve the arguments and `this' object in native functions; for convenience, it is available as the first argument in :class:`QScriptEngine.FunctionSignature<~PySide.QtScript.QScriptEngine.FunctionSignature>` .



.. method:: PySide.QtScript.QScriptEngine.defaultPrototype(metaTypeId)


    :param metaTypeId: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Returns the default prototype associated with the given ``metaTypeId`` , or an invalid :class:`PySide.QtScript.QScriptValue` if no default prototype has been set.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.setDefaultPrototype` 


.. method:: PySide.QtScript.QScriptEngine.evaluate(program[, fileName=""[, lineNumber=1]])


    :param program: unicode
    :param fileName: unicode
    :param lineNumber: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Evaluates ``program`` , using ``lineNumber`` as the base line number, and returns the result of the evaluation.

    The script code will be evaluated in the current context.

    The evaluation of ``program`` can cause an exception in the engine; in this case the return value will be the exception that was thrown (typically an ``Error`` object). You can call :meth:`PySide.QtScript.QScriptEngine.hasUncaughtException` to determine if an exception occurred in the last call to :meth:`PySide.QtScript.QScriptEngine.evaluate` .

    ``lineNumber`` is used to specify a starting line number for ``program`` ; line number information reported by the engine that pertain to this evaluation (e.g. :meth:`PySide.QtScript.QScriptEngine.uncaughtExceptionLineNumber` ) will be based on this argument. For example, if ``program`` consists of two lines of code, and the statement on the second line causes a script exception, :meth:`PySide.QtScript.QScriptEngine.uncaughtExceptionLineNumber` would return the given ``lineNumber`` plus one. When no starting line number is specified, line numbers will be 1-based.

    ``fileName`` is used for error reporting. For example in error objects the file name is accessible through the "fileName" property if it's provided with this function.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.canEvaluate`  :meth:`PySide.QtScript.QScriptEngine.hasUncaughtException`  :meth:`PySide.QtScript.QScriptEngine.isEvaluating`  :meth:`PySide.QtScript.QScriptEngine.abortEvaluation` 


.. method:: PySide.QtScript.QScriptEngine.evaluate(program)


    :param program: :class:`PySide.QtScript.QScriptProgram`
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Evaluates the given ``program`` and returns the result of the evaluation.



.. method:: PySide.QtScript.QScriptEngine.globalObject()


    :rtype: :class:`PySide.QtScript.QScriptValue`




    Returns this engine's Global Object.

    By default, the Global Object contains the built-in objects that are part of :ref:`ECMA-262<http://www.ecma-international.org/publications/standards/Ecma-262.htm>` , such as Math, Date and String. Additionally, you can set properties of the Global Object to make your own extensions available to all script code. Non-local variables in script code will be created as properties of the Global Object, as well as local variables in global code.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.setGlobalObject` 


.. method:: PySide.QtScript.QScriptEngine.hasUncaughtException()


    :rtype: :class:`PySide.QtCore.bool`




    Returns true if the last script evaluation resulted in an uncaught exception; otherwise returns false.

    The exception state is cleared when :meth:`PySide.QtScript.QScriptEngine.evaluate` is called.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.uncaughtException`  :meth:`PySide.QtScript.QScriptEngine.uncaughtExceptionLineNumber` 


.. method:: PySide.QtScript.QScriptEngine.importExtension(extension)


    :param extension: unicode
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Imports the given ``extension`` into this :class:`PySide.QtScript.QScriptEngine` . Returns :meth:`PySide.QtScript.QScriptEngine.undefinedValue` if the extension was successfully imported. You can call :meth:`PySide.QtScript.QScriptEngine.hasUncaughtException` to check if an error occurred; in that case, the return value is the value that was thrown by the exception (usually an ``Error`` object).

    :class:`PySide.QtScript.QScriptEngine` ensures that a particular extension is only imported once; subsequent calls to :meth:`PySide.QtScript.QScriptEngine.importExtension` with the same extension name will do nothing and return :meth:`PySide.QtScript.QScriptEngine.undefinedValue` .

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.availableExtensions`  :class:`PySide.QtScript.QScriptExtensionPlugin`  :ref:`Creating QtScript Extensions<qtscriptextensions.html>` 


.. method:: PySide.QtScript.QScriptEngine.importedExtensions()


    :rtype: list of strings




    Returns a list naming the extensions that have been imported using the :meth:`PySide.QtScript.QScriptEngine.importExtension` function.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.availableExtensions` 


.. method:: PySide.QtScript.QScriptEngine.installTranslatorFunctions([object=QScriptValue()])


    :param object: :class:`PySide.QtScript.QScriptValue`




    Installs translator functions on the given ``object`` , or on the Global Object if no object is specified.

    The relation between Qt Script translator functions and C++ translator functions is described in the following table:

    +-----------------------------------------------------------------+------------------------------------------------------------------------------+
    |Script Function                                                  |Corresponding C++ Function                                                    |
    +-----------------------------------------------------------------+------------------------------------------------------------------------------+
    |qsTr()                                                           |:meth:`QObject.tr()<PySide.QtCore.QObject.tr>`                                |
    +-----------------------------------------------------------------+------------------------------------------------------------------------------+
    |:meth:`~PySide.QtScript.QScriptEngine.QT\_TR\_NOOP`              |:meth:`~PySide.QtScript.QScriptEngine.QT\_TR\_NOOP`                           |
    +-----------------------------------------------------------------+------------------------------------------------------------------------------+
    |qsTranslate()                                                    |:meth:`QCoreApplication.translate()<PySide.QtCore.QCoreApplication.translate>`|
    +-----------------------------------------------------------------+------------------------------------------------------------------------------+
    |:meth:`~PySide.QtScript.QScriptEngine.QT\_TRANSLATE\_NOOP`       |:meth:`~PySide.QtScript.QScriptEngine.QT\_TRANSLATE\_NOOP`                    |
    +-----------------------------------------------------------------+------------------------------------------------------------------------------+
    |qsTrId() (since 4.7)                                             |:meth:`~PySide.QtScript.QScriptEngine.qtTrId`                                 |
    +-----------------------------------------------------------------+------------------------------------------------------------------------------+
    |:meth:`~PySide.QtScript.QScriptEngine.QT\_TRID\_NOOP` (since 4.7)|:meth:`~PySide.QtScript.QScriptEngine.QT\_TRID\_NOOP`                         |
    +-----------------------------------------------------------------+------------------------------------------------------------------------------+

    .. seealso::  :ref:`Internationalization with Qt<internationalization.html>` 


.. method:: PySide.QtScript.QScriptEngine.isEvaluating()


    :rtype: :class:`PySide.QtCore.bool`




    Returns true if this engine is currently evaluating a script, otherwise returns false.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.evaluate`  :meth:`PySide.QtScript.QScriptEngine.abortEvaluation` 


.. method:: PySide.QtScript.QScriptEngine.newActivationObject()


    :rtype: :class:`PySide.QtScript.QScriptValue`






.. method:: PySide.QtScript.QScriptEngine.newArray([length=0])


    :param length: :class:`PySide.QtCore.uint`
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Creates a :ref:`QtScript` object of class Array with the given ``length`` .

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.newObject` 


.. method:: PySide.QtScript.QScriptEngine.newDate(value)


    :param value: :class:`PySide.QtCore.double`
    :rtype: :class:`PySide.QtScript.QScriptValue`







.. method:: PySide.QtScript.QScriptEngine.newDate(value)


    :param value: :class:`PySide.QtCore.QDateTime`
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Creates a :ref:`QtScript` object of class Date from the given ``value`` .

    .. seealso::  :meth:`QScriptValue.toDateTime()<PySide.QtScript.QScriptValue.toDateTime>` 


.. method:: PySide.QtScript.QScriptEngine.newObject()


    :rtype: :class:`PySide.QtScript.QScriptValue`




    Creates a :ref:`QtScript` object of class Object.

    The prototype of the created object will be the Object prototype object.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.newArray`  :meth:`QScriptValue.setProperty()<PySide.QtScript.QScriptValue.setProperty>` 


.. method:: PySide.QtScript.QScriptEngine.newObject(scriptClass[, data=QScriptValue()])


    :param scriptClass: :class:`PySide.QtScript.QScriptClass`
    :param data: :class:`PySide.QtScript.QScriptValue`
    :rtype: :class:`PySide.QtScript.QScriptValue`




    This is an overloaded function.

    Creates a :ref:`QtScript` Object of the given class, ``scriptClass`` .

    The prototype of the created object will be the Object prototype object.

    ``data`` , if specified, is set as the internal data of the new object (using :meth:`QScriptValue.setData()<PySide.QtScript.QScriptValue.setData>` ).

    .. seealso::  :meth:`QScriptValue.scriptClass()<PySide.QtScript.QScriptValue.scriptClass>`  :meth:`PySide.QtScript.QScriptEngine.reportAdditionalMemoryCost` 


.. method:: PySide.QtScript.QScriptEngine.newQMetaObject(metaObject[, ctor=QScriptValue()])


    :param metaObject: :class:`PySide.QtCore.QMetaObject`
    :param ctor: :class:`PySide.QtScript.QScriptValue`
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Creates a :ref:`QtScript` object that represents a :class:`PySide.QtCore.QObject` class, using the the given ``metaObject`` and constructor ``ctor`` .

    Enums of ``metaObject`` (declared with Q\_ENUMS) are available as properties of the created :class:`PySide.QtScript.QScriptValue` . When the class is called as a function, ``ctor`` will be called to create a new instance of the class.

    Example:

    ::

        def mySpecialQObjectConstructor(context, engine):
            parent = context.argument(0).toQObject()
            object =  QObject(parent)
            return engine.QObject(object, QScriptEngine.ScriptOwnership)

        ...

        ctor = engine.Function(mySpecialQObjectConstructor)
        metaObject = engine.QMetaObject(QObject.staticMetaObject, ctor)
        engine.globalObject().setProperty("QObject", metaObject)

        result = engine.evaluate(" QObject()")


    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.newQObject`  :meth:`~PySide.QtScript.QScriptEngine.scriptValueFromQMetaObject` 


.. method:: PySide.QtScript.QScriptEngine.newQObject(object[, ownership=QtOwnership[, options=0]])


    :param object: :class:`PySide.QtCore.QObject`
    :param ownership: :attr:`PySide.QtScript.QScriptEngine.ValueOwnership`
    :param options: :class:`PySide.QtScript.QScriptEngine.QObjectWrapOptions`
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Creates a :ref:`QtScript` object that wraps the given :class:`PySide.QtCore.QObject` ``object`` , using the given ``ownership`` . The given ``options`` control various aspects of the interaction with the resulting script object.

    Signals and slots, properties and children of ``object`` are available as properties of the created :class:`PySide.QtScript.QScriptValue` . For more information, see the :ref:`QtScript` documentation.

    If ``object`` is a null pointer, this function returns :meth:`PySide.QtScript.QScriptEngine.nullValue` .

    If a default prototype has been registered for the ``object`` 's class (or its superclass, recursively), the prototype of the new script object will be set to be that default prototype.

    If the given ``object`` is deleted outside of :ref:`QtScript` 's control, any attempt to access the deleted :class:`PySide.QtCore.QObject` 's members through the :ref:`QtScript` wrapper object (either by script code or C++) will result in a script exception.

    .. seealso::  :meth:`QScriptValue.toQObject()<PySide.QtScript.QScriptValue.toQObject>`  :meth:`PySide.QtScript.QScriptEngine.reportAdditionalMemoryCost` 


.. method:: PySide.QtScript.QScriptEngine.newQObject(scriptObject, qtObject[, ownership=QtOwnership[, options=0]])


    :param scriptObject: :class:`PySide.QtScript.QScriptValue`
    :param qtObject: :class:`PySide.QtCore.QObject`
    :param ownership: :attr:`PySide.QtScript.QScriptEngine.ValueOwnership`
    :param options: :class:`PySide.QtScript.QScriptEngine.QObjectWrapOptions`
    :rtype: :class:`PySide.QtScript.QScriptValue`




    This is an overloaded function.

    Initializes the given ``scriptObject`` to hold the given ``qtObject`` , and returns the ``scriptObject`` .

    This function enables you to "promote" a plain Qt Script object (created by the :meth:`PySide.QtScript.QScriptEngine.newObject` function) to a :class:`PySide.QtCore.QObject` proxy, or to replace the :class:`PySide.QtCore.QObject` contained inside an object previously created by the :meth:`PySide.QtScript.QScriptEngine.newQObject` function.

    The prototype() of the ``scriptObject`` will remain unchanged.

    If ``scriptObject`` is not an object, this function behaves like the normal :meth:`PySide.QtScript.QScriptEngine.newQObject` , i.e. it creates a new script object and returns it.

    This function is useful when you want to provide a script constructor for a :class:`PySide.QtCore.QObject` -based class. If your constructor is invoked in a ``new`` expression ( :meth:`QScriptContext.isCalledAsConstructor()<PySide.QtScript.QScriptContext.isCalledAsConstructor>` returns true), you can pass :meth:`QScriptContext.thisObject()<PySide.QtScript.QScriptContext.thisObject>` (the default constructed script object) to this function to initialize the new object.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.reportAdditionalMemoryCost` 


.. method:: PySide.QtScript.QScriptEngine.newRegExp(pattern, flags)


    :param pattern: unicode
    :param flags: unicode
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Creates a :ref:`QtScript` object of class RegExp with the given ``pattern`` and ``flags`` .

    The legal flags are 'g' (global), 'i' (ignore case), and 'm' (multiline).



.. method:: PySide.QtScript.QScriptEngine.newRegExp(regexp)


    :param regexp: :class:`PySide.QtCore.QRegExp`
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Creates a :ref:`QtScript` object of class RegExp with the given ``regexp`` .

    .. seealso::  :meth:`QScriptValue.toRegExp()<PySide.QtScript.QScriptValue.toRegExp>` 


.. method:: PySide.QtScript.QScriptEngine.newVariant(value)


    :param value: object
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Creates a :ref:`QtScript` object holding the given variant ``value`` .

    If a default prototype has been registered with the meta type id of ``value`` , then the prototype of the created object will be that prototype; otherwise, the prototype will be the Object prototype object.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.setDefaultPrototype`  :meth:`QScriptValue.toVariant()<PySide.QtScript.QScriptValue.toVariant>`  :meth:`PySide.QtScript.QScriptEngine.reportAdditionalMemoryCost` 


.. method:: PySide.QtScript.QScriptEngine.newVariant(object, value)


    :param object: :class:`PySide.QtScript.QScriptValue`
    :param value: object
    :rtype: :class:`PySide.QtScript.QScriptValue`




    This is an overloaded function.

    Initializes the given Qt Script ``object`` to hold the given variant ``value`` , and returns the ``object`` .

    This function enables you to "promote" a plain Qt Script object (created by the :meth:`PySide.QtScript.QScriptEngine.newObject` function) to a variant, or to replace the variant contained inside an object previously created by the :meth:`PySide.QtScript.QScriptEngine.newVariant` function.

    The prototype() of the ``object`` will remain unchanged.

    If ``object`` is not an object, this function behaves like the normal :meth:`PySide.QtScript.QScriptEngine.newVariant` , i.e. it creates a new script object and returns it.

    This function is useful when you want to provide a script constructor for a C++ type. If your constructor is invoked in a ``new`` expression ( :meth:`QScriptContext.isCalledAsConstructor()<PySide.QtScript.QScriptContext.isCalledAsConstructor>` returns true), you can pass :meth:`QScriptContext.thisObject()<PySide.QtScript.QScriptContext.thisObject>` (the default constructed script object) to this function to initialize the new object.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.reportAdditionalMemoryCost` 


.. method:: PySide.QtScript.QScriptEngine.nullValue()


    :rtype: :class:`PySide.QtScript.QScriptValue`




    Returns a :class:`PySide.QtScript.QScriptValue` of the primitive type Null.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.undefinedValue` 


.. method:: PySide.QtScript.QScriptEngine.objectById(id)


    :param id: :class:`PySide.QtCore.qint64`
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Returns the object with the given ``id`` , or an invalid :class:`PySide.QtScript.QScriptValue` if there is no object with that id.

    .. seealso::  :meth:`QScriptValue.objectId()<PySide.QtScript.QScriptValue.objectId>` 


.. method:: PySide.QtScript.QScriptEngine.popContext()






    Pops the current execution context and restores the previous one. This function must be used in conjunction with :meth:`PySide.QtScript.QScriptEngine.pushContext` .

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.pushContext` 


.. method:: PySide.QtScript.QScriptEngine.processEventsInterval()


    :rtype: :class:`PySide.QtCore.int`




    Returns the interval in milliseconds between calls to :meth:`QCoreApplication.processEvents()<PySide.QtCore.QCoreApplication.processEvents>` while the interpreter is running.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.setProcessEventsInterval` 


.. method:: PySide.QtScript.QScriptEngine.pushContext()


    :rtype: :class:`PySide.QtScript.QScriptContext`




    Enters a new execution context and returns the associated :class:`PySide.QtScript.QScriptContext` object.

    Once you are done with the context, you should call :meth:`PySide.QtScript.QScriptEngine.popContext` to restore the old context.

    By default, the `this' object of the new context is the Global Object. The context's :meth:`PySide.QtScript.QScriptContext.callee` () will be invalid.

    This function is useful when you want to evaluate script code as if it were the body of a function. You can use the context's :meth:`PySide.QtScript.QScriptContext.activationObject` () to initialize local variables that will be available to scripts. Example:

    ::

        engine = QScriptEngine()
        context = engine.pushContext()
        context.activationObject().setProperty("myArg", 123)
        engine.evaluate("var tmp = myArg + 42")
        ...
        engine.popContext()


    In the above example, the new variable "tmp" defined in the script will be local to the context; in other words, the script doesn't have any effect on the global environment.

    Returns 0 in case of stack overflow

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.popContext` 


.. method:: PySide.QtScript.QScriptEngine.reportAdditionalMemoryCost(size)


    :param size: :class:`PySide.QtCore.int`




    Reports an additional memory cost of the given ``size`` , measured in bytes, to the garbage collector.

    This function can be called to indicate that a Qt Script object has memory associated with it that isn't managed by Qt Script itself. Reporting the additional cost makes it more likely that the garbage collector will be triggered.

    Note that if the additional memory is shared with objects outside the scripting environment, the cost should not be reported, since collecting the Qt Script object would not cause the memory to be freed anyway.

    Negative ``size`` values are ignored, i.e. this function can't be used to report that the additional memory has been deallocated.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.collectGarbage` 


.. method:: PySide.QtScript.QScriptEngine.setAgent(agent)


    :param agent: :class:`PySide.QtScript.QScriptEngineAgent`




    Installs the given ``agent`` on this engine. The agent will be notified of various events pertaining to script execution. This is useful when you want to find out exactly what the engine is doing, e.g. when :meth:`PySide.QtScript.QScriptEngine.evaluate` is called. The agent interface is the basis of tools like debuggers and profilers.

    The engine maintains ownership of the ``agent`` .

    Calling this function will replace the existing agent, if any.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.agent` 


.. method:: PySide.QtScript.QScriptEngine.setDefaultPrototype(metaTypeId, prototype)


    :param metaTypeId: :class:`PySide.QtCore.int`
    :param prototype: :class:`PySide.QtScript.QScriptValue`




    Sets the default prototype of the C++ type identified by the given ``metaTypeId`` to ``prototype`` .

    The default prototype provides a script interface for values of type ``metaTypeId`` when a value of that type is accessed from script code. Whenever the script engine (implicitly or explicitly) creates a :class:`PySide.QtScript.QScriptValue` from a value of type ``metaTypeId`` , the default prototype will be set as the :class:`PySide.QtScript.QScriptValue` 's prototype.

    The ``prototype`` object itself may be constructed using one of two principal techniques; the simplest is to subclass :class:`PySide.QtScript.QScriptable` , which enables you to define the scripting API of the type through :class:`PySide.QtCore.QObject` properties and slots. Another possibility is to create a script object by calling :meth:`PySide.QtScript.QScriptEngine.newObject` , and populate the object with the desired properties (e.g. native functions wrapped with :meth:`~PySide.QtScript.QScriptEngine.newFunction` ).

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.defaultPrototype`  :meth:`~PySide.QtScript.QScriptEngine.qScriptRegisterMetaType`  :class:`PySide.QtScript.QScriptable`  :ref:`Default Prototypes Example<script/defaultprototypes>` 


.. method:: PySide.QtScript.QScriptEngine.setGlobalObject(object)


    :param object: :class:`PySide.QtScript.QScriptValue`




    Sets this engine's Global Object to be the given ``object`` . If ``object`` is not a valid script object, this function does nothing.

    When setting a custom global object, you may want to use :class:`PySide.QtScript.QScriptValueIterator` to copy the properties of the standard Global Object; alternatively, you can set the internal prototype of your custom object to be the original Global Object.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.globalObject` 


.. method:: PySide.QtScript.QScriptEngine.setProcessEventsInterval(interval)


    :param interval: :class:`PySide.QtCore.int`




    Sets the interval between calls to QCoreApplication::processEvents to ``interval`` milliseconds.

    While the interpreter is running, all event processing is by default blocked. This means for instance that the gui will not be updated and timers will not be fired. To allow event processing during interpreter execution one can specify the processing interval to be a positive value, indicating the number of milliseconds between each time :meth:`QCoreApplication.processEvents()<PySide.QtCore.QCoreApplication.processEvents>` is called.

    The default value is -1, which disables event processing during interpreter execution.

    You can use :meth:`QCoreApplication.postEvent()<PySide.QtCore.QCoreApplication.postEvent>` to post an event that performs custom processing at the next interval. For example, you could keep track of the total running time of the script and call :meth:`PySide.QtScript.QScriptEngine.abortEvaluation` when you detect that the script has been running for a long time without completing.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.processEventsInterval` 


.. method:: PySide.QtScript.QScriptEngine.signalHandlerException(exception)


    :param exception: :class:`PySide.QtScript.QScriptValue`






.. method:: PySide.QtScript.QScriptEngine.toObject(value)


    :param value: :class:`PySide.QtScript.QScriptValue`
    :rtype: :class:`PySide.QtScript.QScriptValue`




    Converts the given ``value`` to an object, if such a conversion is possible; otherwise returns an invalid :class:`PySide.QtScript.QScriptValue` . The conversion is performed according to the following table:

    +----------+-----------------------------------------------------------------------------+
    |Input Type|Result                                                                       |
    +----------+-----------------------------------------------------------------------------+
    |Undefined |An invalid :class:`PySide.QtScript.QScriptValue` .                           |
    +----------+-----------------------------------------------------------------------------+
    |Null      |An invalid :class:`PySide.QtScript.QScriptValue` .                           |
    +----------+-----------------------------------------------------------------------------+
    |Boolean   |A new Boolean object whose internal value is set to the value of the boolean.|
    +----------+-----------------------------------------------------------------------------+
    |Number    |A new Number object whose internal value is set to the value of the number.  |
    +----------+-----------------------------------------------------------------------------+
    |String    |A new String object whose internal value is set to the value of the string.  |
    +----------+-----------------------------------------------------------------------------+
    |Object    |The result is the object itself (no conversion).                             |
    +----------+-----------------------------------------------------------------------------+

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.newObject` 


.. method:: PySide.QtScript.QScriptEngine.toStringHandle(str)


    :param str: unicode
    :rtype: :class:`PySide.QtScript.QScriptString`




    Returns a handle that represents the given string, ``str`` .

    :class:`PySide.QtScript.QScriptString` can be used to quickly look up properties, and compare property names, of script objects.

    .. seealso::  :meth:`QScriptValue.property()<PySide.QtScript.QScriptValue.property>` 


.. method:: PySide.QtScript.QScriptEngine.uncaughtException()


    :rtype: :class:`PySide.QtScript.QScriptValue`




    Returns the current uncaught exception, or an invalid :class:`PySide.QtScript.QScriptValue` if there is no uncaught exception.

    The exception value is typically an ``Error`` object; in that case, you can call :meth:`~PySide.QtScript.QScriptEngine.toString` on the return value to obtain an error message.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.hasUncaughtException`  :meth:`PySide.QtScript.QScriptEngine.uncaughtExceptionLineNumber` 


.. method:: PySide.QtScript.QScriptEngine.uncaughtExceptionBacktrace()


    :rtype: list of strings




    Returns a human-readable backtrace of the last uncaught exception.

    It is in the form ``<function-name>()@<file-name>:<line-number>`` .

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.uncaughtException` 


.. method:: PySide.QtScript.QScriptEngine.uncaughtExceptionLineNumber()


    :rtype: :class:`PySide.QtCore.int`




    Returns the line number where the last uncaught exception occurred.

    Line numbers are 1-based, unless a different base was specified as the second argument to :meth:`PySide.QtScript.QScriptEngine.evaluate` .

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.hasUncaughtException` 


.. method:: PySide.QtScript.QScriptEngine.undefinedValue()


    :rtype: :class:`PySide.QtScript.QScriptValue`




    Returns a :class:`PySide.QtScript.QScriptValue` of the primitive type Undefined.

    .. seealso::  :meth:`PySide.QtScript.QScriptEngine.nullValue` 



