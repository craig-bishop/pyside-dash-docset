.. module:: PySide.QtCore
.. _QByteArray:

QByteArray
**********

.. inheritance-diagram:: QByteArray
    :parts: 2

Synopsis
--------

Functions
^^^^^^^^^
.. container:: function_list

*    def :meth:`__add__<PySide.QtCore.QByteArray.__add__>` (, a2)
*    def :meth:`__add__<PySide.QtCore.QByteArray.__add__>` (, a2)
*    def :meth:`__add__<PySide.QtCore.QByteArray.__add__>` (a1)
*    def :meth:`__add__<PySide.QtCore.QByteArray.__add__>` (arg__1)
*    def :meth:`__add__<PySide.QtCore.QByteArray.__add__>` (arg__1)
*    def :meth:`__add__<PySide.QtCore.QByteArray.__add__>` (arg__1)
*    def :meth:`__eq__<PySide.QtCore.QByteArray.__eq__>` (, a2)
*    def :meth:`__ge__<PySide.QtCore.QByteArray.__ge__>` (, a2)
*    def :meth:`__getitem__<PySide.QtCore.QByteArray.__getitem__>` ()
*    def :meth:`__getslice__<PySide.QtCore.QByteArray.__getslice__>` ()
*    def :meth:`__gt__<PySide.QtCore.QByteArray.__gt__>` (, a2)
*    def :meth:`__iadd__<PySide.QtCore.QByteArray.__iadd__>` (a)
*    def :meth:`__iadd__<PySide.QtCore.QByteArray.__iadd__>` (c)
*    def :meth:`__le__<PySide.QtCore.QByteArray.__le__>` (, a2)
*    def :meth:`__len__<PySide.QtCore.QByteArray.__len__>` ()
*    def :meth:`__lt__<PySide.QtCore.QByteArray.__lt__>` (, a2)
*    def :meth:`__lt__<PySide.QtCore.QByteArray.__lt__>` (, a2)
*    def :meth:`__ne__<PySide.QtCore.QByteArray.__ne__>` (, a2)
*    def :meth:`__reduce__<PySide.QtCore.QByteArray.__reduce__>` ()
*    def :meth:`__repr__<PySide.QtCore.QByteArray.__repr__>` ()
*    def :meth:`__setitem__<PySide.QtCore.QByteArray.__setitem__>` ()
*    def :meth:`__str__<PySide.QtCore.QByteArray.__str__>` ()
*    def :meth:`append<PySide.QtCore.QByteArray.append>` (a)
*    def :meth:`append<PySide.QtCore.QByteArray.append>` (c)
*    def :meth:`at<PySide.QtCore.QByteArray.at>` (i)
*    def :meth:`capacity<PySide.QtCore.QByteArray.capacity>` ()
*    def :meth:`chop<PySide.QtCore.QByteArray.chop>` (n)
*    def :meth:`clear<PySide.QtCore.QByteArray.clear>` ()
*    def :meth:`contains<PySide.QtCore.QByteArray.contains>` (a)
*    def :meth:`contains<PySide.QtCore.QByteArray.contains>` (c)
*    def :meth:`count<PySide.QtCore.QByteArray.count>` ()
*    def :meth:`count<PySide.QtCore.QByteArray.count>` (a)
*    def :meth:`count<PySide.QtCore.QByteArray.count>` (c)
*    def :meth:`data<PySide.QtCore.QByteArray.data>` ()
*    def :meth:`endsWith<PySide.QtCore.QByteArray.endsWith>` (a)
*    def :meth:`endsWith<PySide.QtCore.QByteArray.endsWith>` (c)
*    def :meth:`expand<PySide.QtCore.QByteArray.expand>` (i)
*    def :meth:`fill<PySide.QtCore.QByteArray.fill>` (c[, size=-1])
*    def :meth:`indexOf<PySide.QtCore.QByteArray.indexOf>` (a[, from=0])
*    def :meth:`insert<PySide.QtCore.QByteArray.insert>` (i, a)
*    def :meth:`isEmpty<PySide.QtCore.QByteArray.isEmpty>` ()
*    def :meth:`isNull<PySide.QtCore.QByteArray.isNull>` ()
*    def :meth:`isSharedWith<PySide.QtCore.QByteArray.isSharedWith>` (other)
*    def :meth:`lastIndexOf<PySide.QtCore.QByteArray.lastIndexOf>` (a[, from=-1])
*    def :meth:`left<PySide.QtCore.QByteArray.left>` (len)
*    def :meth:`leftJustified<PySide.QtCore.QByteArray.leftJustified>` (width[, fill=' '[, truncate=false]])
*    def :meth:`length<PySide.QtCore.QByteArray.length>` ()
*    def :meth:`mid<PySide.QtCore.QByteArray.mid>` (index[, len=-1])
*    def :meth:`nulTerminated<PySide.QtCore.QByteArray.nulTerminated>` ()
*    def :meth:`prepend<PySide.QtCore.QByteArray.prepend>` (a)
*    def :meth:`prepend<PySide.QtCore.QByteArray.prepend>` (c)
*    def :meth:`realloc<PySide.QtCore.QByteArray.realloc>` (alloc)
*    def :meth:`remove<PySide.QtCore.QByteArray.remove>` (index, len)
*    def :meth:`repeated<PySide.QtCore.QByteArray.repeated>` (times)
*    def :meth:`replace<PySide.QtCore.QByteArray.replace>` (before, after)
*    def :meth:`replace<PySide.QtCore.QByteArray.replace>` (before, after)
*    def :meth:`replace<PySide.QtCore.QByteArray.replace>` (before, after)
*    def :meth:`replace<PySide.QtCore.QByteArray.replace>` (before, after)
*    def :meth:`replace<PySide.QtCore.QByteArray.replace>` (index, len, s)
*    def :meth:`reserve<PySide.QtCore.QByteArray.reserve>` (size)
*    def :meth:`resize<PySide.QtCore.QByteArray.resize>` (size)
*    def :meth:`right<PySide.QtCore.QByteArray.right>` (len)
*    def :meth:`rightJustified<PySide.QtCore.QByteArray.rightJustified>` (width[, fill=' '[, truncate=false]])
*    def :meth:`setNum<PySide.QtCore.QByteArray.setNum>` (arg__1[, base=10])
*    def :meth:`setNum<PySide.QtCore.QByteArray.setNum>` (arg__1[, base=10])
*    def :meth:`setNum<PySide.QtCore.QByteArray.setNum>` (arg__1[, f='g'[, prec=6]])
*    def :meth:`setRawData<PySide.QtCore.QByteArray.setRawData>` (a, n)
*    def :meth:`simplified<PySide.QtCore.QByteArray.simplified>` ()
*    def :meth:`size<PySide.QtCore.QByteArray.size>` ()
*    def :meth:`split<PySide.QtCore.QByteArray.split>` (sep)
*    def :meth:`squeeze<PySide.QtCore.QByteArray.squeeze>` ()
*    def :meth:`startsWith<PySide.QtCore.QByteArray.startsWith>` (a)
*    def :meth:`startsWith<PySide.QtCore.QByteArray.startsWith>` (c)
*    def :meth:`toBase64<PySide.QtCore.QByteArray.toBase64>` ()
*    def :meth:`toDouble<PySide.QtCore.QByteArray.toDouble>` ()
*    def :meth:`toFloat<PySide.QtCore.QByteArray.toFloat>` ()
*    def :meth:`toHex<PySide.QtCore.QByteArray.toHex>` ()
*    def :meth:`toInt<PySide.QtCore.QByteArray.toInt>` ([, base=10])
*    def :meth:`toLong<PySide.QtCore.QByteArray.toLong>` ([, base=10])
*    def :meth:`toLongLong<PySide.QtCore.QByteArray.toLongLong>` ([, base=10])
*    def :meth:`toLower<PySide.QtCore.QByteArray.toLower>` ()
*    def :meth:`toPercentEncoding<PySide.QtCore.QByteArray.toPercentEncoding>` ([exclude=QByteArray()[, include=QByteArray()[, percent='%']]])
*    def :meth:`toShort<PySide.QtCore.QByteArray.toShort>` ([, base=10])
*    def :meth:`toUInt<PySide.QtCore.QByteArray.toUInt>` ([, base=10])
*    def :meth:`toULong<PySide.QtCore.QByteArray.toULong>` ([, base=10])
*    def :meth:`toULongLong<PySide.QtCore.QByteArray.toULongLong>` ([, base=10])
*    def :meth:`toUShort<PySide.QtCore.QByteArray.toUShort>` ([, base=10])
*    def :meth:`toUpper<PySide.QtCore.QByteArray.toUpper>` ()
*    def :meth:`trimmed<PySide.QtCore.QByteArray.trimmed>` ()
*    def :meth:`truncate<PySide.QtCore.QByteArray.truncate>` (pos)


Static functions
^^^^^^^^^^^^^^^^
.. container:: function_list

*    def :meth:`fromBase64<PySide.QtCore.QByteArray.fromBase64>` (base64)
*    def :meth:`fromHex<PySide.QtCore.QByteArray.fromHex>` (hexEncoded)
*    def :meth:`fromPercentEncoding<PySide.QtCore.QByteArray.fromPercentEncoding>` (pctEncoded[, percent='%'])
*    def :meth:`fromRawData<PySide.QtCore.QByteArray.fromRawData>` (arg__1)
*    def :meth:`number<PySide.QtCore.QByteArray.number>` (arg__1[, base=10])
*    def :meth:`number<PySide.QtCore.QByteArray.number>` (arg__1[, base=10])
*    def :meth:`number<PySide.QtCore.QByteArray.number>` (arg__1[, f='g'[, prec=6]])


Detailed Description
--------------------



    The :class:`PySide.QtCore.QByteArray` class provides an array of bytes.

    :class:`PySide.QtCore.QByteArray` can be used to store both raw bytes (including '\0's) and traditional 8-bit '\0'-terminated strings. Using :class:`PySide.QtCore.QByteArray` is much more convenient than using ``const char *`` . Behind the scenes, it always ensures that the data is followed by a '\0' terminator, and uses :ref:`implicit sharing<implicit-sharing.html>` (copy-on-write) to reduce memory usage and avoid needless copying of data.

    In addition to :class:`PySide.QtCore.QByteArray` , Qt also provides the :class:`PySide.QtCore.QString` class to store string data. For most purposes, :class:`PySide.QtCore.QString` is the class you want to use. It stores 16-bit Unicode characters, making it easy to store non-ASCII/non-Latin-1 characters in your application. Furthermore, :class:`PySide.QtCore.QString` is used throughout in the Qt API. The two main cases where :class:`PySide.QtCore.QByteArray` is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g., with Qt for Embedded Linux).

    One way to initialize a :class:`PySide.QtCore.QByteArray` is simply to pass a ``const char *`` to its constructor. For example, the following code creates a byte array of size 5 containing the data "Hello":

    ::

        ba = QByteArray("Hello")


    Although the :meth:`PySide.QtCore.QByteArray.size` is 5, the byte array also maintains an extra '\0' character at the end so that if a function is used that asks for a pointer to the underlying data (e.g. a call to :meth:`PySide.QtCore.QByteArray.data` ), the data pointed to is guaranteed to be '\0'-terminated.

    :class:`PySide.QtCore.QByteArray` makes a deep copy of the ``const char *`` data, so you can modify it later without experiencing side effects. (If for performance reasons you don't want to take a deep copy of the character data, use :meth:`QByteArray.fromRawData()<PySide.QtCore.QByteArray.fromRawData>` instead.)

    Another approach is to set the size of the array using :meth:`PySide.QtCore.QByteArray.resize` and to initialize the data byte per byte. :class:`PySide.QtCore.QByteArray` uses 0-based indexes, just like C++ arrays. To access the byte at a particular index position, you can use operator[](). On non-const byte arrays, operator[]() returns a reference to a byte that can be used on the left side of an assignment. For example:

    ::

        ba = QByteArray()
        ba.resize(5)
        ba[0] = 'H'
        ba[1] = 'e'
        ba[2] = 'l'
        ba[3] = 'l'
        ba[4] = 'o'


    For read-only access, an alternative syntax is to use :meth:`PySide.QtCore.QByteArray.at` :

    ::

        for i in range(0, ba.size()):
            if ba.at(i) >= 'a' and ba.at(i) <= 'f':
                print "Found character in range [a-f]"


    :meth:`PySide.QtCore.QByteArray.at` can be faster than operator[](), because it never causes a :ref:`deep copy<implicit-sharing.html>` to occur.

    To extract many bytes at a time, use :meth:`PySide.QtCore.QByteArray.left` , :meth:`PySide.QtCore.QByteArray.right` , or :meth:`PySide.QtCore.QByteArray.mid` .

    A :class:`PySide.QtCore.QByteArray` can embed '\0' bytes. The :meth:`PySide.QtCore.QByteArray.size` function always returns the size of the whole array, including embedded '\0' bytes. If you want to obtain the length of the data up to and excluding the first '\0' character, call :meth:`~PySide.QtCore.QByteArray.qstrlen` on the byte array.

    After a call to :meth:`PySide.QtCore.QByteArray.resize` , newly allocated bytes have undefined values. To set all the bytes to a particular value, call :meth:`PySide.QtCore.QByteArray.fill` .

    To obtain a pointer to the actual character data, call :meth:`PySide.QtCore.QByteArray.data` or :meth:`PySide.QtCore.QByteArray.constData` . These functions return a pointer to the beginning of the data. The pointer is guaranteed to remain valid until a non-const function is called on the :class:`PySide.QtCore.QByteArray` . It is also guaranteed that the data ends with a '\0' byte. This '\0' byte is automatically provided by :class:`PySide.QtCore.QByteArray` and is not counted in :meth:`PySide.QtCore.QByteArray.size` .

    :class:`PySide.QtCore.QByteArray` provides the following basic functions for modifying the byte data: :meth:`PySide.QtCore.QByteArray.append` , :meth:`PySide.QtCore.QByteArray.prepend` , :meth:`PySide.QtCore.QByteArray.insert` , :meth:`PySide.QtCore.QByteArray.replace` , and :meth:`PySide.QtCore.QByteArray.remove` . For example:

    ::

        x = QByteArray("and")
        x.prepend("rock ")         # x == "rock and"
        x.append(" roll")          # x == "rock and roll"
        x.replace(5, 3, "&")       # x == "rock & roll"


    The :meth:`PySide.QtCore.QByteArray.replace` and :meth:`PySide.QtCore.QByteArray.remove` functions' first two arguments are the position from which to start erasing and the number of bytes that should be erased.

    When you :meth:`PySide.QtCore.QByteArray.append` data to a non-empty array, the array will be reallocated and the new data copied to it. You can avoid this behavior by calling :meth:`PySide.QtCore.QByteArray.reserve` , which preallocates a certain amount of memory. You can also call :meth:`PySide.QtCore.QByteArray.capacity` to find out how much memory :class:`PySide.QtCore.QByteArray` actually allocated. Data appended to an empty array is not copied.

    A frequent requirement is to remove whitespace characters from a byte array ('\n', '\t', ' ', etc.). If you want to remove whitespace from both ends of a :class:`PySide.QtCore.QByteArray` , use :meth:`PySide.QtCore.QByteArray.trimmed` . If you want to remove whitespace from both ends and replace multiple consecutive whitespaces with a single space character within the byte array, use :meth:`PySide.QtCore.QByteArray.simplified` .

    If you want to find all occurrences of a particular character or substring in a :class:`PySide.QtCore.QByteArray` , use :meth:`PySide.QtCore.QByteArray.indexOf` or :meth:`PySide.QtCore.QByteArray.lastIndexOf` . The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular substring:

    ::

        ba = QByteArray("We must be <b>bold</b>, very <b>bold</b>")
        j = 0
        while (j = ba.indexOf("<b>", j)) != -1:
            print "Found <b> tag at index position %d" % j
            ++j


    If you simply want to check whether a :class:`PySide.QtCore.QByteArray` contains a particular character or substring, use :meth:`PySide.QtCore.QByteArray.contains` . If you want to find out how many times a particular character or substring occurs in the byte array, use :meth:`PySide.QtCore.QByteArray.count` . If you want to replace all occurrences of a particular value with another, use one of the two-parameter :meth:`PySide.QtCore.QByteArray.replace` overloads.

    QByteArrays can be compared using overloaded operators such as operator<(), operator<=(), operator==(), operator>=(), and so on. The comparison is based exclusively on the numeric values of the characters and is very fast, but is not what a human would expect. :meth:`QString.localeAwareCompare` is a better choice for sorting user-interface strings.

    For historical reasons, :class:`PySide.QtCore.QByteArray` distinguishes between a null byte array and an empty byte array. A *null* byte array is a byte array that is initialized using :class:`PySide.QtCore.QByteArray` 's default constructor or by passing (const char \*)0 to the constructor. An *empty* byte array is any byte array with size 0. A null byte array is always empty, but an empty byte array isn't necessarily null:

    ::

        QByteArray().isNull()          # returns true
        QByteArray().isEmpty()         # returns true

        QByteArray("").isNull()        # returns false
        QByteArray("").isEmpty()       # returns true

        QByteArray("abc").isNull()     # returns false
        QByteArray("abc").isEmpty()    # returns false


    All functions except :meth:`PySide.QtCore.QByteArray.isNull` treat null byte arrays the same as empty byte arrays. For example, :meth:`PySide.QtCore.QByteArray.data` returns a pointer to a '\0' character for a null byte array (*not* a null pointer), and :meth:`PySide.QtCore.QByteArray.QByteArray` compares equal to :class:`PySide.QtCore.QByteArray` (""). We recommend that you always use :meth:`PySide.QtCore.QByteArray.isEmpty` and avoid :meth:`PySide.QtCore.QByteArray.isNull` .

    .. _PySide.QtCore.QByteArray_notes-on-locale:



Notes on Locale
^^^^^^^^^^^^^^^

    .. _PySide.QtCore.QByteArray_number-string-conversions:



Number-String Conversions
^^^^^^^^^^^^^^^^^^^^^^^^^

    Functions that perform conversions between numeric data types and strings are performed in the C locale, irrespective of the user's locale settings. Use :class:`PySide.QtCore.QString` to perform locale-aware conversions between numbers and strings.

    .. _PySide.QtCore.QByteArray_8-bit-character-comparisons:



8-bit Character Comparisons
^^^^^^^^^^^^^^^^^^^^^^^^^^^

    In :class:`PySide.QtCore.QByteArray` , the notion of uppercase and lowercase and of which character is greater than or less than another character is locale dependent. This affects functions that support a case insensitive option or that compare or lowercase or uppercase their arguments. Case insensitive operations and comparisons will be accurate if both strings contain only ASCII characters. (If ``$LC_CTYPE`` is set, most Unix systems do "the right thing".) Functions that this affects include :meth:`PySide.QtCore.QByteArray.contains` , :meth:`PySide.QtCore.QByteArray.indexOf` , :meth:`PySide.QtCore.QByteArray.lastIndexOf` , operator<(), operator<=(), operator>(), operator>=(), :meth:`PySide.QtCore.QByteArray.toLower` and :meth:`PySide.QtCore.QByteArray.toUpper` .

    This issue does not apply to QStrings since they represent characters using Unicode.

    .. seealso::  :class:`PySide.QtCore.QString`  :class:`PySide.QtCore.QBitArray` 

.. class:: QByteArray()
           QByteArray(arg__1)
           QByteArray(arg__1)
           QByteArray(size, c)

    :param size: :class:`PySide.QtCore.int`
    :param arg__1: :class:`PySide.QtCore.QByteArray`
    :param c: :class:`PySide.QtCore.char`

    Constructs an empty byte array.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.isEmpty` 

    Constructs a copy of ``other`` .

    This operation takes :ref:`constant time<containers.html>` , because :class:`PySide.QtCore.QByteArray` is :ref:`implicitly shared<implicit-sharing.html>` . This makes returning a :class:`PySide.QtCore.QByteArray` from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), taking :ref:`linear time<containers.html>` .

    .. seealso::  :meth:`PySide.QtCore.QByteArray.operator=` 

    Constructs a byte array initialized with the string ``str`` .

    :class:`PySide.QtCore.QByteArray` makes a deep copy of the string data.



    Constructs a byte array of size ``size`` with every byte set to character ``ch`` .

    .. seealso::  :meth:`PySide.QtCore.QByteArray.fill` 

.. method:: PySide.QtCore.QByteArray.__getitem__()









.. method:: PySide.QtCore.QByteArray.__getslice__()









.. method:: PySide.QtCore.QByteArray.__len__()









.. method:: PySide.QtCore.QByteArray.__reduce__()


    :rtype: :class:`PyObject`







.. method:: PySide.QtCore.QByteArray.__repr__()


    :rtype: :class:`PyObject`







.. method:: PySide.QtCore.QByteArray.__setitem__()









.. method:: PySide.QtCore.QByteArray.__str__()


    :rtype: :class:`PyObject`







.. method:: PySide.QtCore.QByteArray.append(c)


    :param c: :class:`PySide.QtCore.char`
    :rtype: :class:`PySide.QtCore.QByteArray`




    This is an overloaded function.

    Appends the character ``ch`` to this byte array.



.. method:: PySide.QtCore.QByteArray.append(a)


    :param a: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Appends the byte array ``ba`` onto the end of this byte array.

    Example:

    ::

        x = QByteArray("free")
        y = QByteArray("dom")
        x.append(y)
        # x == "freedom"


    This is the same as insert( :meth:`PySide.QtCore.QByteArray.size` , ``ba`` ).

    Note: :class:`PySide.QtCore.QByteArray` is an :ref:`implicitly shared<implicit-sharing.html>` class. Consequently, if *this* is an empty :class:`PySide.QtCore.QByteArray` , then *this* will just share the data held in ``ba`` . In this case, no copying of data is done, taking :ref:`constant time<containers.html>` . If a shared instance is modified, it will be copied (copy-on-write), taking :ref:`linear time<containers.html>` .

    If *this* is not an empty :class:`PySide.QtCore.QByteArray` , a deep copy of the data is performed, taking :ref:`linear time<containers.html>` .

    This operation typically does not suffer from allocation overhead, because :class:`PySide.QtCore.QByteArray` preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.operator+=`  :meth:`PySide.QtCore.QByteArray.prepend`  :meth:`PySide.QtCore.QByteArray.insert` 


.. method:: PySide.QtCore.QByteArray.at(i)


    :param i: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.char`




    Returns the character at index position ``i`` in the byte array.

    ``i`` must be a valid index position in the byte array (i.e., 0 <= ``i`` < :meth:`PySide.QtCore.QByteArray.size` ).

    .. seealso::  :meth:`PySide.QtCore.QByteArray.operator[]` 


.. method:: PySide.QtCore.QByteArray.capacity()


    :rtype: :class:`PySide.QtCore.int`




    Returns the maximum number of bytes that can be stored in the byte array without forcing a reallocation.

    The sole purpose of this function is to provide a means of fine tuning :class:`PySide.QtCore.QByteArray` 's memory usage. In general, you will rarely ever need to call this function. If you want to know how many bytes are in the byte array, call :meth:`PySide.QtCore.QByteArray.size` .

    .. seealso::  :meth:`PySide.QtCore.QByteArray.reserve`  :meth:`PySide.QtCore.QByteArray.squeeze` 


.. method:: PySide.QtCore.QByteArray.chop(n)


    :param n: :class:`PySide.QtCore.int`




    Removes ``n`` bytes from the end of the byte array.

    If ``n`` is greater than :meth:`PySide.QtCore.QByteArray.size` , the result is an empty byte array.

    Example:

    ::

        ba = QByteArray("STARTTLS\r\n")
        ba.chop(2)                 # ba == "STARTTLS"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.truncate`  :meth:`PySide.QtCore.QByteArray.resize`  :meth:`PySide.QtCore.QByteArray.left` 


.. method:: PySide.QtCore.QByteArray.clear()






    Clears the contents of the byte array and makes it empty.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.resize`  :meth:`PySide.QtCore.QByteArray.isEmpty` 


.. method:: PySide.QtCore.QByteArray.contains(a)


    :param a: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.QBool`




    Returns true if the byte array contains an occurrence of the byte array ``ba`` ; otherwise returns false.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.indexOf`  :meth:`PySide.QtCore.QByteArray.count` 


.. method:: PySide.QtCore.QByteArray.contains(c)


    :param c: :class:`PySide.QtCore.char`
    :rtype: :class:`PySide.QtCore.QBool`




    This is an overloaded function.

    Returns true if the byte array contains the character ``ch`` ; otherwise returns false.



.. method:: PySide.QtCore.QByteArray.count(a)


    :param a: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.int`




    Returns the number of (potentially overlapping) occurrences of byte array ``ba`` in this byte array.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.contains`  :meth:`PySide.QtCore.QByteArray.indexOf` 


.. method:: PySide.QtCore.QByteArray.count(c)


    :param c: :class:`PySide.QtCore.char`
    :rtype: :class:`PySide.QtCore.int`




    This is an overloaded function.

    Returns the number of occurrences of character ``ch`` in the byte array.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.contains`  :meth:`PySide.QtCore.QByteArray.indexOf` 


.. method:: PySide.QtCore.QByteArray.count()


    :rtype: :class:`PySide.QtCore.int`




    This is an overloaded function.

    Same as :meth:`PySide.QtCore.QByteArray.size` .



.. method:: PySide.QtCore.QByteArray.data()


    :rtype: str




    This is an overloaded function.



.. method:: PySide.QtCore.QByteArray.endsWith(a)


    :param a: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.bool`




    Returns true if this byte array ends with byte array ``ba`` ; otherwise returns false.

    Example:

    ::

        url = QByteArray("http://qtsoftware.com/index.html")
        if url.endsWith(".html"):
            ...


    .. seealso::  :meth:`PySide.QtCore.QByteArray.startsWith`  :meth:`PySide.QtCore.QByteArray.right` 


.. method:: PySide.QtCore.QByteArray.endsWith(c)


    :param c: :class:`PySide.QtCore.char`
    :rtype: :class:`PySide.QtCore.bool`




    This is an overloaded function.

    Returns true if this byte array ends with character ``ch`` ; otherwise returns false.



.. method:: PySide.QtCore.QByteArray.expand(i)


    :param i: :class:`PySide.QtCore.int`






.. method:: PySide.QtCore.QByteArray.fill(c[, size=-1])


    :param c: :class:`PySide.QtCore.char`
    :param size: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Sets every byte in the byte array to character ``ch`` . If ``size`` is different from -1 (the default), the byte array is resized to size ``size`` beforehand.

    Example:

    ::

        ba = QByteArray("Istambul")
        ba.fill('o')
        # ba == "oooooooo"

        ba.fill('X', 2)
        # ba == "XX"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.resize` 


.. staticmethod:: PySide.QtCore.QByteArray.fromBase64(base64)


    :param base64: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a decoded copy of the Base64 array ``base64`` . Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.

    For example:

    ::

        text = QByteArray.fromBase64("UXQgaXMgZ3JlYXQh")
        text.data()            # returns "Qt is great!"


    The algorithm used to decode Base64-encoded data is defined in :ref:`RFC 2045<http://www.rfc-editor.org/rfc/rfc2045.txt>` .

    .. seealso::  :meth:`PySide.QtCore.QByteArray.toBase64` 


.. staticmethod:: PySide.QtCore.QByteArray.fromHex(hexEncoded)


    :param hexEncoded: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a decoded copy of the hex encoded array ``hexEncoded`` . Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.

    For example:

    ::

        text = QByteArray.fromHex("517420697320677265617421")
        text.data()            # returns "Qt is great!"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.toHex` 


.. staticmethod:: PySide.QtCore.QByteArray.fromPercentEncoding(pctEncoded[, percent='%'])


    :param pctEncoded: :class:`PySide.QtCore.QByteArray`
    :param percent: :class:`PySide.QtCore.char`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a decoded copy of the URI/URL-style percent-encoded ``input`` . The ``percent`` parameter allows you to replace the '%' character for another (for instance, ' :ref:`_<index.html>` ' or '=').

    For example:

    ::

                QByteArray text = QByteArray::fromPercentEncoding("Qt%20is%20great%33");
                text.data();            // returns "Qt is great!"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.toPercentEncoding`  :meth:`QUrl.fromPercentEncoding()<PySide.QtCore.QUrl.fromPercentEncoding>` 


.. staticmethod:: PySide.QtCore.QByteArray.fromRawData(arg__1)


    :param arg__1: str
    :rtype: :class:`PySide.QtCore.QByteArray`




    Constructs a :class:`PySide.QtCore.QByteArray` that uses the first ``size`` bytes of the ``data`` array. The bytes are *not* copied. The :class:`PySide.QtCore.QByteArray` will contain the ``data`` pointer. The caller guarantees that ``data`` will not be deleted or modified as long as this :class:`PySide.QtCore.QByteArray` and any copies of it exist that have not been modified. In other words, because :class:`PySide.QtCore.QByteArray` is an :ref:`implicitly shared<implicit-sharing.html>` class and the instance returned by this function contains the ``data`` pointer, the caller must not delete ``data`` or modify it directly as long as the returned :class:`PySide.QtCore.QByteArray` and any copies exist. However, :class:`PySide.QtCore.QByteArray` does not take ownership of ``data`` , so the :class:`PySide.QtCore.QByteArray` destructor will never delete the raw ``data`` , even when the last :class:`PySide.QtCore.QByteArray` referring to ``data`` is destroyed.

    A subsequent attempt to modify the contents of the returned :class:`PySide.QtCore.QByteArray` or any copy made from it will cause it to create a deep copy of the ``data`` array before doing the modification. This ensures that the raw ``data`` array itself will never be modified by :class:`PySide.QtCore.QByteArray` .

    Here is an example of how to read data using a :class:`PySide.QtCore.QDataStream` on raw data in memory without copying the raw data into a :class:`PySide.QtCore.QByteArray` :

    ::

        mydata = '\x00\x00\x03\x84\x78\x9c\x3b\x76'\
                 '\xec\x18\xc3\x31\x0a\xf1\xcc\x99'\
                 ...
                 '\x6d\x5b'

        data = QByteArray.fromRawData(mydata)
        in_ = QDataStream(data, QIODevice.ReadOnly)
        ...


    .. warning::  A byte array created with :meth:`PySide.QtCore.QByteArray.fromRawData` is *not* null-terminated, unless the raw data contains a 0 character at position ``size`` . While that does not matter for :class:`PySide.QtCore.QDataStream` or functions like :meth:`PySide.QtCore.QByteArray.indexOf` , passing the byte array to a function accepting a ``const char *`` expected to be '\0'-terminated will fail.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.setRawData`  :meth:`PySide.QtCore.QByteArray.data`  :meth:`PySide.QtCore.QByteArray.constData` 


.. method:: PySide.QtCore.QByteArray.indexOf(a[, from=0])


    :param a: :class:`PySide.QtCore.QByteArray`
    :param from: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.int`




    Returns the index position of the first occurrence of the byte array ``ba`` in this byte array, searching forward from index position ``from`` . Returns -1 if ``ba`` could not be found.

    Example:

    ::

        x = QByteArray("sticky question")
        y = QByteArray("sti")
        x.indexOf(y)               # returns 0
        x.indexOf(y, 1)            # returns 10
        x.indexOf(y, 10)           # returns 10
        x.indexOf(y, 11)           # returns -1


    .. seealso::  :meth:`PySide.QtCore.QByteArray.lastIndexOf`  :meth:`PySide.QtCore.QByteArray.contains`  :meth:`PySide.QtCore.QByteArray.count` 


.. method:: PySide.QtCore.QByteArray.insert(i, a)


    :param i: :class:`PySide.QtCore.int`
    :param a: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Inserts the byte array ``ba`` at index position ``i`` and returns a reference to this byte array.

    Example:

    ::

        ba = QByteArray("Meal")
        ba.insert(1, QByteArray("ontr"))
        # ba == "Montreal"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.append`  :meth:`PySide.QtCore.QByteArray.prepend`  :meth:`PySide.QtCore.QByteArray.replace`  :meth:`PySide.QtCore.QByteArray.remove` 


.. method:: PySide.QtCore.QByteArray.isEmpty()


    :rtype: :class:`PySide.QtCore.bool`




    Returns true if the byte array has size 0; otherwise returns false.

    Example:

    ::

        QByteArray().isEmpty()         # returns true
        QByteArray("").isEmpty()       # returns true
        QByteArray("abc").isEmpty()    # returns false


    .. seealso::  :meth:`PySide.QtCore.QByteArray.size` 


.. method:: PySide.QtCore.QByteArray.isNull()


    :rtype: :class:`PySide.QtCore.bool`




    Returns true if this byte array is null; otherwise returns false.

    Example:

    ::

        QByteArray().isNull()          # returns true
        QByteArray("").isNull()        # returns false
        QByteArray("abc").isNull()     # returns false


    Qt makes a distinction between null byte arrays and empty byte arrays for historical reasons. For most applications, what matters is whether or not a byte array contains any data, and this can be determined using :meth:`PySide.QtCore.QByteArray.isEmpty` .

    .. seealso::  :meth:`PySide.QtCore.QByteArray.isEmpty` 


.. method:: PySide.QtCore.QByteArray.isSharedWith(other)


    :param other: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.bool`






.. method:: PySide.QtCore.QByteArray.lastIndexOf(a[, from=-1])


    :param a: :class:`PySide.QtCore.QByteArray`
    :param from: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.int`




    Returns the index position of the last occurrence of the byte array ``ba`` in this byte array, searching backward from index position ``from`` . If ``from`` is -1 (the default), the search starts at the last byte. Returns -1 if ``ba`` could not be found.

    Example:

    ::

        x = QByteArray("crazy azimuths")
        y = QByteArray("azy")
        x.lastIndexOf(y)           # returns 6
        x.lastIndexOf(y, 6)        # returns 6
        x.lastIndexOf(y, 5)        # returns 2
        x.lastIndexOf(y, 1)        # returns -1


    .. seealso::  :meth:`PySide.QtCore.QByteArray.indexOf`  :meth:`PySide.QtCore.QByteArray.contains`  :meth:`PySide.QtCore.QByteArray.count` 


.. method:: PySide.QtCore.QByteArray.left(len)


    :param len: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a byte array that contains the leftmost ``len`` bytes of this byte array.

    The entire byte array is returned if ``len`` is greater than :meth:`PySide.QtCore.QByteArray.size` .

    Example:

    ::

        x = QByteArray("Pineapple")
        y = x.left(4)
        # y == "Pine"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.right`  :meth:`PySide.QtCore.QByteArray.mid`  :meth:`PySide.QtCore.QByteArray.startsWith`  :meth:`PySide.QtCore.QByteArray.truncate` 


.. method:: PySide.QtCore.QByteArray.leftJustified(width[, fill=' '[, truncate=false]])


    :param width: :class:`PySide.QtCore.int`
    :param fill: :class:`PySide.QtCore.char`
    :param truncate: :class:`PySide.QtCore.bool`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a byte array of size ``width`` that contains this byte array padded by the ``fill`` character.

    If ``truncate`` is false and the :meth:`PySide.QtCore.QByteArray.size` of the byte array is more than ``width`` , then the returned byte array is a copy of this byte array.

    If ``truncate`` is true and the :meth:`PySide.QtCore.QByteArray.size` of the byte array is more than ``width`` , then any bytes in a copy of the byte array after position ``width`` are removed, and the copy is returned.

    Example:

    ::

        x = QByteArray("apple")
        y = x.leftJustified(8, '.')   # y == "apple..."


    .. seealso::  :meth:`PySide.QtCore.QByteArray.rightJustified` 


.. method:: PySide.QtCore.QByteArray.length()


    :rtype: :class:`PySide.QtCore.int`




    Same as :meth:`PySide.QtCore.QByteArray.size` .



.. method:: PySide.QtCore.QByteArray.mid(index[, len=-1])


    :param index: :class:`PySide.QtCore.int`
    :param len: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a byte array containing ``len`` bytes from this byte array, starting at position ``pos`` .

    If ``len`` is -1 (the default), or ``pos`` + ``len`` >= :meth:`PySide.QtCore.QByteArray.size` , returns a byte array containing all bytes starting at position ``pos`` until the end of the byte array.

    Example:

    ::

        x = QByteArray("Five pineapples")
        y = x.mid(5, 4)     # y == "pine"
        z = x.mid(5)        # z == "pineapples"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.left`  :meth:`PySide.QtCore.QByteArray.right` 


.. method:: PySide.QtCore.QByteArray.nulTerminated()


    :rtype: :class:`PySide.QtCore.QByteArray`






.. staticmethod:: PySide.QtCore.QByteArray.number(arg__1[, base=10])


    :param arg__1: :class:`PySide.QtCore.int`
    :param base: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a byte array containing the string equivalent of the number ``n`` to base ``base`` (10 by default). The ``base`` can be any value between 2 and 36.

    Example:

    ::

        n = 63;
        QByteArray.number(n)               # returns "63"
        QByteArray.number(n, 16)           # returns "3f"
        QByteArray.number(n, 16).toUpper() # returns "3F"


    .. note::  The format of the number is not localized; the default C locale is used irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.setNum`  :meth:`PySide.QtCore.QByteArray.toInt` 


.. staticmethod:: PySide.QtCore.QByteArray.number(arg__1[, base=10])


    :param arg__1: :class:`PySide.QtCore.qlonglong`
    :param base: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.QByteArray`




    This is an overloaded function.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.toLongLong` 


.. staticmethod:: PySide.QtCore.QByteArray.number(arg__1[, f='g'[, prec=6]])


    :param arg__1: :class:`PySide.QtCore.double`
    :param f: :class:`PySide.QtCore.char`
    :param prec: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.QByteArray`




    This is an overloaded function.

    Returns a byte array that contains the printed value of ``n`` , formatted in format ``f`` with precision ``prec`` .

    Argument ``n`` is formatted according to the ``f`` format specified, which is ``g`` by default, and can be any of the following:

    +------+--------------------------------------------------------+
    |Format|Meaning                                                 |
    +------+--------------------------------------------------------+
    |``e``\|format as [-]9.9e[+|-]999                               |
    +------+--------------------------------------------------------+
    |``E``\|format as [-]9.9E[+|-]999                               |
    +------+--------------------------------------------------------+
    |``f``\|format as [-]9.9                                        |
    +------+--------------------------------------------------------+
    |``g``\|use ``e`` or ``f`` format, whichever is the most concise|
    +------+--------------------------------------------------------+
    |``G``\|use ``E`` or ``f`` format, whichever is the most concise|
    +------+--------------------------------------------------------+

    With 'e', 'E', and 'f', ``prec`` is the number of digits after the decimal point. With 'g' and 'G', ``prec`` is the maximum number of significant digits (trailing zeroes are omitted).

    ::

        ba = QByteArray.number(12.3456, 'E', 3)
        # ba == 1.235E+01


    .. note::  The format of the number is not localized; the default C locale is used irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.toDouble` 


.. method:: PySide.QtCore.QByteArray.__ne__(, a2)


    :param a2: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QByteArray.__add__(, a2)


    :param a2: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.QByteArray`







.. method:: PySide.QtCore.QByteArray.__add__(arg__1)


    :param arg__1: :class:`PyUnicode`







.. method:: PySide.QtCore.QByteArray.__add__(, a2)


    :param a2: :class:`PySide.QtCore.char`
    :rtype: :class:`PySide.QtCore.QByteArray`







.. method:: PySide.QtCore.QByteArray.__add__(arg__1)


    :param arg__1: :class:`PyBytes`







.. method:: PySide.QtCore.QByteArray.__add__(arg__1)


    :param arg__1: :class:`PyUnicode`







.. method:: PySide.QtCore.QByteArray.__add__(a1)


    :param a1: :class:`PySide.QtCore.char`
    :rtype: :class:`PySide.QtCore.QByteArray`







.. method:: PySide.QtCore.QByteArray.__iadd__(a)


    :param a: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Appends the byte array ``ba`` onto the end of this byte array and returns a reference to this byte array.

    Example:

    ::

        x = QByteArray("free")
        y = QByteArray("dom");
        x += y
        # x == "freedom"


    Note: :class:`PySide.QtCore.QByteArray` is an :ref:`implicitly shared<implicit-sharing.html>` class. Consequently, if *this* is an empty :class:`PySide.QtCore.QByteArray` , then *this* will just share the data held in ``ba`` . In this case, no copying of data is done, taking :ref:`constant time<containers.html>` . If a shared instance is modified, it will be copied (copy-on-write), taking :ref:`linear time<containers.html>` .

    If *this* is not an empty :class:`PySide.QtCore.QByteArray` , a deep copy of the data is performed, taking :ref:`linear time<containers.html>` .

    This operation typically does not suffer from allocation overhead, because :class:`PySide.QtCore.QByteArray` preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.append`  :meth:`PySide.QtCore.QByteArray.prepend` 


.. method:: PySide.QtCore.QByteArray.__iadd__(c)


    :param c: :class:`PySide.QtCore.char`
    :rtype: :class:`PySide.QtCore.QByteArray`




    This is an overloaded function.

    Appends the character ``ch`` onto the end of this byte array and returns a reference to this byte array.



.. method:: PySide.QtCore.QByteArray.__lt__(, a2)


    :param a2: str
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QByteArray.__lt__(, a2)


    :param a2: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QByteArray.__le__(, a2)


    :param a2: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QByteArray.__eq__(, a2)


    :param a2: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QByteArray.__gt__(, a2)


    :param a2: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QByteArray.__ge__(, a2)


    :param a2: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QByteArray.prepend(a)


    :param a: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Prepends the byte array ``ba`` to this byte array and returns a reference to this byte array.

    Example:

    ::

        x = QByteArray("ship")
        y = QByteArray("air")
        x.prepend(y)
        # x == "airship"


    This is the same as insert(0, ``ba`` ).

    Note: :class:`PySide.QtCore.QByteArray` is an :ref:`implicitly shared<implicit-sharing.html>` class. Consequently, if *this* is an empty :class:`PySide.QtCore.QByteArray` , then *this* will just share the data held in ``ba`` . In this case, no copying of data is done, taking :ref:`constant time<containers.html>` . If a shared instance is modified, it will be copied (copy-on-write), taking :ref:`linear time<containers.html>` .

    If *this* is not an empty :class:`PySide.QtCore.QByteArray` , a deep copy of the data is performed, taking :ref:`linear time<containers.html>` .

    .. seealso::  :meth:`PySide.QtCore.QByteArray.append`  :meth:`PySide.QtCore.QByteArray.insert` 


.. method:: PySide.QtCore.QByteArray.prepend(c)


    :param c: :class:`PySide.QtCore.char`
    :rtype: :class:`PySide.QtCore.QByteArray`




    This is an overloaded function.

    Prepends the character ``ch`` to this byte array.



.. method:: PySide.QtCore.QByteArray.realloc(alloc)


    :param alloc: :class:`PySide.QtCore.int`






.. method:: PySide.QtCore.QByteArray.remove(index, len)


    :param index: :class:`PySide.QtCore.int`
    :param len: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Removes ``len`` bytes from the array, starting at index position ``pos`` , and returns a reference to the array.

    If ``pos`` is out of range, nothing happens. If ``pos`` is valid, but ``pos`` + ``len`` is larger than the size of the array, the array is truncated at position ``pos`` .

    Example:

    ::

        ba = QByteArray("Montreal")
        ba.remove(1, 4)
        # ba == "Meal"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.insert`  :meth:`PySide.QtCore.QByteArray.replace` 


.. method:: PySide.QtCore.QByteArray.repeated(times)


    :param times: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a copy of this byte array repeated the specified number of ``times`` .

    If ``times`` is less than 1, an empty byte array is returned.

    Example:

    ::

                QByteArray ba("ab");
                ba.repeated(4);             // returns "abababab"




.. method:: PySide.QtCore.QByteArray.replace(index, len, s)


    :param index: :class:`PySide.QtCore.int`
    :param len: :class:`PySide.QtCore.int`
    :param s: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Replaces ``len`` bytes from index position ``pos`` with the byte array ``after`` , and returns a reference to this byte array.

    Example:

    ::

        x = QByteArray("Say yes!")
        y = QByteArray("no")
        x.replace(4, 3, y)
        # x == "Say no!"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.insert`  :meth:`PySide.QtCore.QByteArray.remove` 


.. method:: PySide.QtCore.QByteArray.replace(before, after)


    :param before: unicode
    :param after: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.QByteArray`




    This is an overloaded function.

    Replaces every occurrence of the string ``before`` with the byte array ``after`` . The Unicode data is converted into 8-bit characters using :meth:`QString.toAscii` .

    If the :class:`PySide.QtCore.QString` contains non-ASCII Unicode characters, using this function can lead to loss of information. You can disable this function by defining ``QT_NO_CAST_TO_ASCII`` when you compile your applications. You then need to call :meth:`QString.toAscii` (or :meth:`QString.toLatin1` or :meth:`QString.toUtf8` or :meth:`QString.toLocal8Bit` ) explicitly if you want to convert the data to ``const char *`` .



.. method:: PySide.QtCore.QByteArray.replace(before, after)


    :param before: :class:`PySide.QtCore.char`
    :param after: :class:`PySide.QtCore.char`
    :rtype: :class:`PySide.QtCore.QByteArray`




    This is an overloaded function.

    Replaces every occurrence of the character ``before`` with the character ``after`` .



.. method:: PySide.QtCore.QByteArray.replace(before, after)


    :param before: :class:`PySide.QtCore.char`
    :param after: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.QByteArray`




    This is an overloaded function.

    Replaces every occurrence of the character ``before`` with the byte array ``after`` .



.. method:: PySide.QtCore.QByteArray.replace(before, after)


    :param before: :class:`PySide.QtCore.QByteArray`
    :param after: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.QByteArray`




    This is an overloaded function.

    Replaces every occurrence of the byte array ``before`` with the byte array ``after`` .

    Example:

    ::

        ba = QByteArray("colour behaviour flavour neighbour")
        ba.replace(QByteArray("ou"), QByteArray("o"))
        # ba == "color behavior flavor neighbor"




.. method:: PySide.QtCore.QByteArray.reserve(size)


    :param size: :class:`PySide.QtCore.int`




    Attempts to allocate memory for at least ``size`` bytes. If you know in advance how large the byte array will be, you can call this function, and if you call :meth:`PySide.QtCore.QByteArray.resize` often you are likely to get better performance. If ``size`` is an underestimate, the worst that will happen is that the :class:`PySide.QtCore.QByteArray` will be a bit slower.

    The sole purpose of this function is to provide a means of fine tuning :class:`PySide.QtCore.QByteArray` 's memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the byte array, call :meth:`PySide.QtCore.QByteArray.resize` .

    .. seealso::  :meth:`PySide.QtCore.QByteArray.squeeze`  :meth:`PySide.QtCore.QByteArray.capacity` 


.. method:: PySide.QtCore.QByteArray.resize(size)


    :param size: :class:`PySide.QtCore.int`




    Sets the size of the byte array to ``size`` bytes.

    If ``size`` is greater than the current size, the byte array is extended to make it ``size`` bytes with the extra bytes added to the end. The new bytes are uninitialized.

    If ``size`` is less than the current size, bytes are removed from the end.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.size` 


.. method:: PySide.QtCore.QByteArray.right(len)


    :param len: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a byte array that contains the rightmost ``len`` bytes of this byte array.

    The entire byte array is returned if ``len`` is greater than :meth:`PySide.QtCore.QByteArray.size` .

    Example:

    ::

        x = QByteArray("Pineapple")
        y = x.right(5)
        # y == "apple"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.endsWith`  :meth:`PySide.QtCore.QByteArray.left`  :meth:`PySide.QtCore.QByteArray.mid` 


.. method:: PySide.QtCore.QByteArray.rightJustified(width[, fill=' '[, truncate=false]])


    :param width: :class:`PySide.QtCore.int`
    :param fill: :class:`PySide.QtCore.char`
    :param truncate: :class:`PySide.QtCore.bool`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a byte array of size ``width`` that contains the ``fill`` character followed by this byte array.

    If ``truncate`` is false and the size of the byte array is more than ``width`` , then the returned byte array is a copy of this byte array.

    If ``truncate`` is true and the size of the byte array is more than ``width`` , then the resulting byte array is truncated at position ``width`` .

    Example:

    ::

        x = QByteArray("apple")
        y = x.rightJustified(8, '.')    # y == "...apple"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.leftJustified` 


.. method:: PySide.QtCore.QByteArray.setNum(arg__1[, f='g'[, prec=6]])


    :param arg__1: :class:`PySide.QtCore.double`
    :param f: :class:`PySide.QtCore.char`
    :param prec: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.QByteArray`




    This is an overloaded function.

    Sets the byte array to the printed value of ``n`` , formatted in format ``f`` with precision ``prec`` , and returns a reference to the byte array.

    The format ``f`` can be any of the following:

    +------+--------------------------------------------------------+
    |Format|Meaning                                                 |
    +------+--------------------------------------------------------+
    |``e``\|format as [-]9.9e[+|-]999                               |
    +------+--------------------------------------------------------+
    |``E``\|format as [-]9.9E[+|-]999                               |
    +------+--------------------------------------------------------+
    |``f``\|format as [-]9.9                                        |
    +------+--------------------------------------------------------+
    |``g``\|use ``e`` or ``f`` format, whichever is the most concise|
    +------+--------------------------------------------------------+
    |``G``\|use ``E`` or ``f`` format, whichever is the most concise|
    +------+--------------------------------------------------------+

    With 'e', 'E', and 'f', ``prec`` is the number of digits after the decimal point. With 'g' and 'G', ``prec`` is the maximum number of significant digits (trailing zeroes are omitted).

    .. note::  The format of the number is not localized; the default C locale is used irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.toDouble` 


.. method:: PySide.QtCore.QByteArray.setNum(arg__1[, base=10])


    :param arg__1: :class:`PySide.QtCore.qlonglong`
    :param base: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.QByteArray`




    This is an overloaded function.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.toLongLong` 


.. method:: PySide.QtCore.QByteArray.setNum(arg__1[, base=10])


    :param arg__1: :class:`PySide.QtCore.int`
    :param base: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Sets the byte array to the printed value of ``n`` in base ``base`` (10 by default) and returns a reference to the byte array. The ``base`` can be any value between 2 and 36.

    Example:

    ::

        ba = QByteArray()
        n = 63
        ba.setNum(n)           # ba == "63"
        ba.setNum(n, 16)       # ba == "3f"


    .. note::  The format of the number is not localized; the default C locale is used irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.number`  :meth:`PySide.QtCore.QByteArray.toInt` 


.. method:: PySide.QtCore.QByteArray.setRawData(a, n)


    :param a: str
    :param n: :class:`PySide.QtCore.uint`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Resets the :class:`PySide.QtCore.QByteArray` to use the first ``size`` bytes of the ``data`` array. The bytes are *not* copied. The :class:`PySide.QtCore.QByteArray` will contain the ``data`` pointer. The caller guarantees that ``data`` will not be deleted or modified as long as this :class:`PySide.QtCore.QByteArray` and any copies of it exist that have not been modified.

    This function can be used instead of :meth:`PySide.QtCore.QByteArray.fromRawData` to re-use existings :class:`PySide.QtCore.QByteArray` objects to save memory re-allocations.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.fromRawData`  :meth:`PySide.QtCore.QByteArray.data`  :meth:`PySide.QtCore.QByteArray.constData` 


.. method:: PySide.QtCore.QByteArray.simplified()


    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a byte array that has whitespace removed from the start and the end, and which has each sequence of internal whitespace replaced with a single space.

    Whitespace means any character for which the standard C++ isspace() function returns true. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.

    Example:

    ::

        ba = QByteArray("  lots\t of\nwhitespace\r\n ")
        ba = ba.simplified()
        # ba == "lots of whitespace";


    .. seealso::  :meth:`PySide.QtCore.QByteArray.trimmed` 


.. method:: PySide.QtCore.QByteArray.size()


    :rtype: :class:`PySide.QtCore.int`




    Returns the number of bytes in this byte array.

    The last byte in the byte array is at position :meth:`PySide.QtCore.QByteArray.size` - 1. In addition, :class:`PySide.QtCore.QByteArray` ensures that the byte at position :meth:`PySide.QtCore.QByteArray.size` is always '\0', so that you can use the return value of :meth:`PySide.QtCore.QByteArray.data` and :meth:`PySide.QtCore.QByteArray.constData` as arguments to functions that expect '\0'-terminated strings.

    Example:

    ::

        ba = QByteArray("Hello")
        n = ba.size()          # n == 5
        ba.data()[0]           # returns 'H'
        ba.data()[4]           # returns 'o'


    .. seealso::  :meth:`PySide.QtCore.QByteArray.isEmpty`  :meth:`PySide.QtCore.QByteArray.resize` 


.. method:: PySide.QtCore.QByteArray.split(sep)


    :param sep: :class:`PySide.QtCore.char`
    :rtype: 




    Splits the byte array into subarrays wherever ``sep`` occurs, and returns the list of those arrays. If ``sep`` does not match anywhere in the byte array, :meth:`PySide.QtCore.QByteArray.split` returns a single-element list containing this byte array.



.. method:: PySide.QtCore.QByteArray.squeeze()






    Releases any memory not required to store the array's data.

    The sole purpose of this function is to provide a means of fine tuning :class:`PySide.QtCore.QByteArray` 's memory usage. In general, you will rarely ever need to call this function.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.reserve`  :meth:`PySide.QtCore.QByteArray.capacity` 


.. method:: PySide.QtCore.QByteArray.startsWith(a)


    :param a: :class:`PySide.QtCore.QByteArray`
    :rtype: :class:`PySide.QtCore.bool`




    Returns true if this byte array starts with byte array ``ba`` ; otherwise returns false.

    Example:

    ::

        url = QByteArray("ftp://ftp.trolltech.com/")
        if url.startsWith("ftp:"):
            ...


    .. seealso::  :meth:`PySide.QtCore.QByteArray.endsWith`  :meth:`PySide.QtCore.QByteArray.left` 


.. method:: PySide.QtCore.QByteArray.startsWith(c)


    :param c: :class:`PySide.QtCore.char`
    :rtype: :class:`PySide.QtCore.bool`




    This is an overloaded function.

    Returns true if this byte array starts with character ``ch`` ; otherwise returns false.



.. method:: PySide.QtCore.QByteArray.toBase64()


    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a copy of the byte array, encoded as Base64.

    ::

        text = QByteArray("Qt is great!")
        text.toBase64()        # returns "UXQgaXMgZ3JlYXQh"


    The algorithm used to encode Base64-encoded data is defined in :ref:`RFC 2045<http://www.rfc-editor.org/rfc/rfc2045.txt>` .

    .. seealso::  :meth:`PySide.QtCore.QByteArray.fromBase64` 


.. method:: PySide.QtCore.QByteArray.toDouble()


    :rtype: :class:`PySide.QtCore.double`




    Returns the byte array converted to a ``double`` value.

    Returns 0.0 if the conversion fails.

    If ``ok`` is not 0: if a conversion error occurs, \*``ok`` is set to false; otherwise \*``ok`` is set to true.

    ::

        string = QByteArray("1234.56")
        (a, ok) = string.toDouble()   # a == 1234.56, ok == true


    .. note::  The conversion of the number is performed in the default C locale, irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.number` 


.. method:: PySide.QtCore.QByteArray.toFloat()


    :rtype: :class:`PySide.QtCore.float`




    Returns the byte array converted to a ``float`` value.

    Returns 0.0 if the conversion fails.

    If ``ok`` is not 0: if a conversion error occurs, \*``ok`` is set to false; otherwise \*``ok`` is set to true.

    .. note::  The conversion of the number is performed in the default C locale, irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.number` 


.. method:: PySide.QtCore.QByteArray.toHex()


    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and the letters a-f.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.fromHex` 


.. method:: PySide.QtCore.QByteArray.toInt([, base=10])


    :param base: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.int`




    Returns the byte array converted to an ``int`` using base ``base`` , which is 10 by default and must be between 2 and 36, or 0.

    If ``base`` is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

    Returns 0 if the conversion fails.

    If ``ok`` is not 0: if a conversion error occurs, \*``ok`` is set to false; otherwise \*``ok`` is set to true.

    ::

        string = QByteArray("FF")
        (hex, ok) = string.toInt(16)   # hex == 255, ok == true
        (dec, ok) = string.toInt(10)   # dec == 0, ok == false


    .. note::  The conversion of the number is performed in the default C locale, irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.number` 


.. method:: PySide.QtCore.QByteArray.toLong([, base=10])


    :param base: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.long`




    Returns the byte array converted to a ``long`` int using base ``base`` , which is 10 by default and must be between 2 and 36, or 0.

    If ``base`` is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

    Returns 0 if the conversion fails.

    If ``ok`` is not 0: if a conversion error occurs, \*``ok`` is set to false; otherwise \*``ok`` is set to true.

    ::

        string = QByteArray("FF")
        (hex, ok) = str.toLong(16);    # hex == 255, ok == true
        (dec, ok) = str.toLong(10);    # dec == 0, ok == false


    .. note::  The conversion of the number is performed in the default C locale, irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.number` 


.. method:: PySide.QtCore.QByteArray.toLongLong([, base=10])


    :param base: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.qlonglong`




    Returns the byte array converted to a ``long long`` using base ``base`` , which is 10 by default and must be between 2 and 36, or 0.

    If ``base`` is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

    Returns 0 if the conversion fails.

    If ``ok`` is not 0: if a conversion error occurs, \*``ok`` is set to false; otherwise \*``ok`` is set to true.

    .. note::  The conversion of the number is performed in the default C locale, irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.number` 


.. method:: PySide.QtCore.QByteArray.toLower()


    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a lowercase copy of the byte array. The bytearray is interpreted as a Latin-1 encoded string.

    Example:

    ::

        x = QByteArray("TROlltECH")
        y = x.toLower()
        # y == "trolltech"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.toUpper`  :class:`~PySide.QtCore.8-bit Character Comparisons` 


.. method:: PySide.QtCore.QByteArray.toPercentEncoding([exclude=QByteArray()[, include=QByteArray()[, percent='%']]])


    :param exclude: :class:`PySide.QtCore.QByteArray`
    :param include: :class:`PySide.QtCore.QByteArray`
    :param percent: :class:`PySide.QtCore.char`
    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a URI/URL-style percent-encoded copy of this byte array. The ``percent`` parameter allows you to override the default '%' character for another.

    By default, this function will encode all characters that are not one of the following:

    ALPHA ("a" to "z" and "A" to "Z") / DIGIT (0 to 9) / "-" / "." / " :ref:`_<index.html>` " / "~"

    To prevent characters from being encoded pass them to ``exclude`` . To force characters to be encoded pass them to ``include`` . The ``percent`` character is always encoded.

    Example:

    ::

                QByteArray text = "{a fishy string?}";
                QByteArray ba = text.toPercentEncoding("{}", "s");
                qDebug(ba.constData());
                // prints "{a fi%73hy %73tring%3F}"


    The hex encoding uses the numbers 0-9 and the uppercase letters A-F.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.fromPercentEncoding`  :meth:`QUrl.toPercentEncoding()<PySide.QtCore.QUrl.toPercentEncoding>` 


.. method:: PySide.QtCore.QByteArray.toShort([, base=10])


    :param base: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.short`




    Returns the byte array converted to a ``short`` using base ``base`` , which is 10 by default and must be between 2 and 36, or 0.

    If ``base`` is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

    Returns 0 if the conversion fails.

    If ``ok`` is not 0: if a conversion error occurs, \*``ok`` is set to false; otherwise \*``ok`` is set to true.

    .. note::  The conversion of the number is performed in the default C locale, irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.number` 


.. method:: PySide.QtCore.QByteArray.toUInt([, base=10])


    :param base: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.uint`




    Returns the byte array converted to an ``unsigned int`` using base ``base`` , which is 10 by default and must be between 2 and 36, or 0.

    If ``base`` is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

    Returns 0 if the conversion fails.

    If ``ok`` is not 0: if a conversion error occurs, \*``ok`` is set to false; otherwise \*``ok`` is set to true.

    .. note::  The conversion of the number is performed in the default C locale, irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.number` 


.. method:: PySide.QtCore.QByteArray.toULong([, base=10])


    :param base: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.ulong`




    Returns the byte array converted to an ``unsigned long int`` using base ``base`` , which is 10 by default and must be between 2 and 36, or 0.

    If ``base`` is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

    Returns 0 if the conversion fails.

    If ``ok`` is not 0: if a conversion error occurs, \*``ok`` is set to false; otherwise \*``ok`` is set to true.

    .. note::  The conversion of the number is performed in the default C locale, irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.number` 


.. method:: PySide.QtCore.QByteArray.toULongLong([, base=10])


    :param base: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.qulonglong`




    Returns the byte array converted to an ``unsigned long long`` using base ``base`` , which is 10 by default and must be between 2 and 36, or 0.

    If ``base`` is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

    Returns 0 if the conversion fails.

    If ``ok`` is not 0: if a conversion error occurs, \*``ok`` is set to false; otherwise \*``ok`` is set to true.

    .. note::  The conversion of the number is performed in the default C locale, irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.number` 


.. method:: PySide.QtCore.QByteArray.toUShort([, base=10])


    :param base: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.ushort`




    Returns the byte array converted to an ``unsigned short`` using base ``base`` , which is 10 by default and must be between 2 and 36, or 0.

    If ``base`` is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.

    Returns 0 if the conversion fails.

    If ``ok`` is not 0: if a conversion error occurs, \*``ok`` is set to false; otherwise \*``ok`` is set to true.

    .. note::  The conversion of the number is performed in the default C locale, irrespective of the user's locale.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.number` 


.. method:: PySide.QtCore.QByteArray.toUpper()


    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns an uppercase copy of the byte array. The bytearray is interpreted as a Latin-1 encoded string.

    Example:

    ::

        x = QByteArray("TROlltECH")
        y = x.toUpper()
        # y == "TROLLTECH"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.toLower`  :class:`~PySide.QtCore.8-bit Character Comparisons` 


.. method:: PySide.QtCore.QByteArray.trimmed()


    :rtype: :class:`PySide.QtCore.QByteArray`




    Returns a byte array that has whitespace removed from the start and the end.

    Whitespace means any character for which the standard C++ isspace() function returns true. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.

    Example:

    ::

        ba = QByteArray("  lots\t of\nwhitespace\r\n ");
        ba = ba.trimmed();
        # ba == "lots\t of\nwhitespace";


    Unlike :meth:`PySide.QtCore.QByteArray.simplified` , :meth:`PySide.QtCore.QByteArray.trimmed` leaves internal whitespace alone.

    .. seealso::  :meth:`PySide.QtCore.QByteArray.simplified` 


.. method:: PySide.QtCore.QByteArray.truncate(pos)


    :param pos: :class:`PySide.QtCore.int`




    Truncates the byte array at index position ``pos`` .

    If ``pos`` is beyond the end of the array, nothing happens.

    Example:

    ::

        ba = QByteArray("Stockholm")
        ba.truncate(5)             # ba == "Stock"


    .. seealso::  :meth:`PySide.QtCore.QByteArray.chop`  :meth:`PySide.QtCore.QByteArray.resize`  :meth:`PySide.QtCore.QByteArray.left` 



