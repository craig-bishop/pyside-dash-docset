.. module:: PySide.QtCore
.. _QObject:

QObject
*******

.. inheritance-diagram:: QObject
    :parts: 2

**Inherited by:** :ref:`QGLShaderProgram`, :ref:`QGraphicsTransform`, :ref:`QGraphicsRotation`, :ref:`QGraphicsScale`, :ref:`QGLShader`, :ref:`QStyle`, :ref:`QCommonStyle`, :ref:`QWindowsStyle`, :ref:`QPlastiqueStyle`, :ref:`QCleanlooksStyle`, :ref:`QGtkStyle`, :ref:`QMotifStyle`, :ref:`QCDEStyle`, :ref:`QButtonGroup`, :ref:`QDrag`, :ref:`QTcpServer`, :ref:`QGraphicsScene`, :ref:`QHelpSearchEngine`, :ref:`QValidator`, :ref:`QRegExpValidator`, :ref:`QDoubleValidator`, :ref:`QIntValidator`, :ref:`QLocalServer`, :ref:`QSettings`, :ref:`QGraphicsItemAnimation`, :ref:`QUiLoader`, :ref:`QHelpEngineCore`, :ref:`QHelpEngine`, :ref:`QGraphicsAnchor`, :ref:`QFileSystemWatcher`, :ref:`QSound`, :ref:`QShortcut`, :ref:`QSessionManager`, :ref:`QWebPluginFactory`, :ref:`QGesture`, :ref:`QTapAndHoldGesture`, :ref:`QTapGesture`, :ref:`QSwipeGesture`, :ref:`QPinchGesture`, :ref:`QPanGesture`, :ref:`QWebHistoryInterface`, :ref:`QClipboard`, :ref:`QWebPage`, :ref:`QThreadPool`, :ref:`QThread`, :ref:`QActionGroup`, :ref:`QAction`, :ref:`QWidgetAction`, :ref:`QPluginLoader`, :ref:`QSyntaxHighlighter`, :ref:`QAbstractUriResolver`, :ref:`QAbstractAnimation`, :ref:`QVariantAnimation`, :ref:`QPropertyAnimation`, :ref:`QPauseAnimation`, :ref:`QAnimationGroup`, :ref:`QSequentialAnimationGroup`, :ref:`QParallelAnimationGroup`, :ref:`QSvgRenderer`, :ref:`QInputContext`, :ref:`QTextObject`, :ref:`QTextFrame`, :ref:`QTextTable`, :ref:`QTextBlockGroup`, :ref:`QTextList`, :ref:`QAbstractTextDocumentLayout`, :ref:`QPlainTextDocumentLayout`, :ref:`QAbstractTransition`, :ref:`QSignalTransition`, :ref:`QEventTransition`, :ref:`QMouseEventTransition`, :ref:`QKeyEventTransition`, :ref:`QSqlDriver`, :ref:`QAbstractState`, :ref:`QState`, :ref:`QStateMachine`, :ref:`QHistoryState`, :ref:`QFinalState`, :ref:`QTimeLine`, :ref:`QDeclarativeExpression`, :ref:`QDataWidgetMapper`, :ref:`QDeclarativeEngine`, :ref:`QDeclarativeContext`, :ref:`QDeclarativeComponent`, :ref:`QGraphicsEffect`, :ref:`QGraphicsOpacityEffect`, :ref:`QGraphicsDropShadowEffect`, :ref:`QGraphicsBlurEffect`, :ref:`QGraphicsColorizeEffect`, :ref:`QAbstractItemDelegate`, :ref:`QItemDelegate`, :ref:`QSqlRelationalDelegate`, :ref:`QStyledItemDelegate`, :ref:`QDeclarativePropertyMap`, :ref:`QItemSelectionModel`, :ref:`QScriptEngineDebugger`, :ref:`QUndoStack`, :ref:`QTranslator`, :ref:`QTimer`, :ref:`QUndoGroup`, :ref:`QSystemTrayIcon`, :ref:`QScriptEngine`, :ref:`QSocketNotifier`, :ref:`QSignalMapper`, :ref:`QCompleter`, :ref:`QMimeData`, :ref:`QNetworkSession`, :ref:`QAbstractItemModel`, :ref:`QDirModel`, :ref:`QAbstractListModel`, :ref:`QStringListModel`, :ref:`QHelpIndexModel`, :ref:`QAbstractTableModel`, :ref:`QSqlQueryModel`, :ref:`QSqlTableModel`, :ref:`QSqlRelationalTableModel`, :ref:`QAbstractProxyModel`, :ref:`QSortFilterProxyModel`, :ref:`QStandardItemModel`, :ref:`QProxyModel`, :ref:`QHelpContentModel`, :ref:`QFileSystemModel`, :ref:`QNetworkConfigurationManager`, :ref:`QNetworkCookieJar`, :ref:`QIODevice`, :ref:`QLocalSocket`, :ref:`QFile`, :ref:`QTemporaryFile`, :ref:`QAbstractSocket`, :ref:`QProcess`, :ref:`QNetworkReply`, :ref:`QUdpSocket`, :ref:`QBuffer`, :ref:`QTcpSocket`, :ref:`QAbstractEventDispatcher`, :ref:`QNetworkAccessManager`, :ref:`QEventLoop`, :ref:`QCoreApplication`, :ref:`QApplication`, :ref:`QHttp`, :ref:`QFtp`, :ref:`QAbstractNetworkCache`, :ref:`QNetworkDiskCache`, :ref:`QSslSocket`, :ref:`QTextDocument`, :ref:`QAbstractMessageHandler`, :ref:`QWebFrame`, :ref:`QMovie`

Synopsis
--------

Functions
^^^^^^^^^
.. container:: function_list

*    def :meth:`blockSignals<PySide.QtCore.QObject.blockSignals>` (b)
*    def :meth:`children<PySide.QtCore.QObject.children>` ()
*    def :meth:`connect<PySide.QtCore.QObject.connect>` (arg__1, arg__2, arg__3[, type=Qt.AutoConnection])
*    def :meth:`connect<PySide.QtCore.QObject.connect>` (arg__1, arg__2[, type=Qt.AutoConnection])
*    def :meth:`connect<PySide.QtCore.QObject.connect>` (sender, signal, member[, type=Qt.AutoConnection])
*    def :meth:`disconnect<PySide.QtCore.QObject.disconnect>` (arg__1, arg__2)
*    def :meth:`disconnect<PySide.QtCore.QObject.disconnect>` (receiver[, member=0])
*    def :meth:`disconnect<PySide.QtCore.QObject.disconnect>` (signal, receiver, member)
*    def :meth:`dumpObjectInfo<PySide.QtCore.QObject.dumpObjectInfo>` ()
*    def :meth:`dumpObjectTree<PySide.QtCore.QObject.dumpObjectTree>` ()
*    def :meth:`dynamicPropertyNames<PySide.QtCore.QObject.dynamicPropertyNames>` ()
*    def :meth:`emit<PySide.QtCore.QObject.emit>` (arg__1, arg__2)
*    def :meth:`findChild<PySide.QtCore.QObject.findChild>` (arg__1[, arg__2=""])
*    def :meth:`findChildren<PySide.QtCore.QObject.findChildren>` (arg__1, arg__2)
*    def :meth:`findChildren<PySide.QtCore.QObject.findChildren>` (arg__1[, arg__2=""])
*    def :meth:`inherits<PySide.QtCore.QObject.inherits>` (classname)
*    def :meth:`installEventFilter<PySide.QtCore.QObject.installEventFilter>` (arg__1)
*    def :meth:`isWidgetType<PySide.QtCore.QObject.isWidgetType>` ()
*    def :meth:`killTimer<PySide.QtCore.QObject.killTimer>` (id)
*    def :meth:`moveToThread<PySide.QtCore.QObject.moveToThread>` (thread)
*    def :meth:`objectName<PySide.QtCore.QObject.objectName>` ()
*    def :meth:`parent<PySide.QtCore.QObject.parent>` ()
*    def :meth:`property<PySide.QtCore.QObject.property>` (name)
*    def :meth:`receivers<PySide.QtCore.QObject.receivers>` (signal)
*    def :meth:`removeEventFilter<PySide.QtCore.QObject.removeEventFilter>` (arg__1)
*    def :meth:`sender<PySide.QtCore.QObject.sender>` ()
*    def :meth:`setObjectName<PySide.QtCore.QObject.setObjectName>` (name)
*    def :meth:`setParent<PySide.QtCore.QObject.setParent>` (arg__1)
*    def :meth:`setProperty<PySide.QtCore.QObject.setProperty>` (name, value)
*    def :meth:`signalsBlocked<PySide.QtCore.QObject.signalsBlocked>` ()
*    def :meth:`startTimer<PySide.QtCore.QObject.startTimer>` (interval)
*    def :meth:`thread<PySide.QtCore.QObject.thread>` ()
*    def :meth:`tr<PySide.QtCore.QObject.tr>` (arg__1[, arg__2=0[, arg__3=-1]])
*    def :meth:`trUtf8<PySide.QtCore.QObject.trUtf8>` (arg__1[, arg__2=0[, arg__3=-1]])
*    def :meth:`trUtf8<PySide.QtCore.QObject.trUtf8>` (arg__1[, arg__2=0[, arg__3=-1]])


Virtual functions
^^^^^^^^^^^^^^^^^
.. container:: function_list

*    def :meth:`childEvent<PySide.QtCore.QObject.childEvent>` (arg__1)
*    def :meth:`connectNotify<PySide.QtCore.QObject.connectNotify>` (signal)
*    def :meth:`customEvent<PySide.QtCore.QObject.customEvent>` (arg__1)
*    def :meth:`disconnectNotify<PySide.QtCore.QObject.disconnectNotify>` (signal)
*    def :meth:`event<PySide.QtCore.QObject.event>` (arg__1)
*    def :meth:`eventFilter<PySide.QtCore.QObject.eventFilter>` (arg__1, arg__2)
*    def :meth:`metaObject<PySide.QtCore.QObject.metaObject>` ()
*    def :meth:`timerEvent<PySide.QtCore.QObject.timerEvent>` (arg__1)


Slots
^^^^^
.. container:: function_list

*    def :meth:`deleteLater<PySide.QtCore.QObject.deleteLater>` ()


Signals
^^^^^^^
.. container:: function_list

*    def :meth:`destroyed<PySide.QtCore.QObject.destroyed>` ([object=None])


Static functions
^^^^^^^^^^^^^^^^
.. container:: function_list

*    def :meth:`connect<PySide.QtCore.QObject.connect>` (arg__1, arg__2, arg__3[, type=Qt.AutoConnection])
*    def :meth:`connect<PySide.QtCore.QObject.connect>` (sender, signal, receiver, member[, type=Qt.AutoConnection])
*    def :meth:`disconnect<PySide.QtCore.QObject.disconnect>` (arg__1, arg__2, arg__3)
*    def :meth:`disconnect<PySide.QtCore.QObject.disconnect>` (sender, signal, receiver, member)
*    def :meth:`registerUserData<PySide.QtCore.QObject.registerUserData>` ()


Detailed Description
--------------------



    The :class:`PySide.QtCore.QObject` class is the base class of all Qt objects.

    :class:`PySide.QtCore.QObject` is the heart of the Qt :ref:`Object Model<object.html>` . The central feature in this model is a very powerful mechanism for seamless object communication called :ref:`signals and slots<signalsandslots.html>` . You can connect a signal to a slot with :meth:`PySide.QtCore.QObject.connect` and destroy the connection with :meth:`PySide.QtCore.QObject.disconnect` . To avoid never ending notification loops you can temporarily block signals with :meth:`PySide.QtCore.QObject.blockSignals` . The protected functions :meth:`PySide.QtCore.QObject.connectNotify` and :meth:`PySide.QtCore.QObject.disconnectNotify` make it possible to track connections.

    :ref:`QObjects<qtwebkit-bridge.html>` organize themselves in :ref:`object trees<objecttrees.html>` . When you create a :class:`PySide.QtCore.QObject` with another object as parent, the object will automatically add itself to the parent's :meth:`PySide.QtCore.QObject.children` list. The parent takes ownership of the object; i.e., it will automatically delete its children in its destructor. You can look for an object by name and optionally type using :meth:`PySide.QtCore.QObject.findChild` or :meth:`PySide.QtCore.QObject.findChildren` .

    Every object has an :meth:`PySide.QtCore.QObject.objectName` and its class name can be found via the corresponding :meth:`PySide.QtCore.QObject.metaObject` (see :meth:`QMetaObject.className()<PySide.QtCore.QMetaObject.className>` ). You can determine whether the object's class inherits another class in the :class:`PySide.QtCore.QObject` inheritance hierarchy by using the :meth:`PySide.QtCore.QObject.inherits` function.

    When an object is deleted, it emits a :meth:`PySide.QtCore.QObject.destroyed` signal. You can catch this signal to avoid dangling references to :ref:`QObjects<qtwebkit-bridge.html>` .

    :ref:`QObjects<qtwebkit-bridge.html>` can receive events through :meth:`PySide.QtCore.QObject.event` and filter the events of other objects. See :meth:`PySide.QtCore.QObject.installEventFilter` and :meth:`PySide.QtCore.QObject.eventFilter` for details. A convenience handler, :meth:`PySide.QtCore.QObject.childEvent` , can be reimplemented to catch child events.

    Events are delivered in the thread in which the object was created; see :ref:`Thread Support in Qt<threads.html>` and :meth:`PySide.QtCore.QObject.thread` for details. Note that event processing is not done at all for :ref:`QObjects<qtwebkit-bridge.html>` with no thread affinity ( :meth:`PySide.QtCore.QObject.thread` returns zero). Use the :meth:`PySide.QtCore.QObject.moveToThread` function to change the thread affinity for an object and its children (the object cannot be moved if it has a parent).

    Last but not least, :class:`PySide.QtCore.QObject` provides the basic timer support in Qt; see :class:`PySide.QtCore.QTimer` for high-level support for timers.

    Notice that the :meth:`~PySide.QtCore.QObject.Q\_OBJECT` macro is mandatory for any object that implements signals, slots or properties. You also need to run the :ref:`Meta Object Compiler<moc.html>` on the source file. We strongly recommend the use of this macro in all subclasses of :class:`PySide.QtCore.QObject` regardless of whether or not they actually use signals, slots and properties, since failure to do so may lead certain functions to exhibit strange behavior.

    All Qt widgets inherit :class:`PySide.QtCore.QObject` . The convenience function :meth:`PySide.QtCore.QObject.isWidgetType` returns whether an object is actually a widget. It is much faster than :meth:`~PySide.QtCore.QObject.qobject\_cast` < :class:`PySide.QtGui.QWidget` \*>(*obj* ) or *obj* -> :meth:`PySide.QtCore.QObject.inherits` (" :class:`PySide.QtGui.QWidget` ").

    Some :class:`PySide.QtCore.QObject` functions, e.g. :meth:`PySide.QtCore.QObject.children` , return a :class:`~PySide.QtCore.QObjectList` . :class:`~PySide.QtCore.QObjectList` is a typedef for :class:`QList` < :class:`PySide.QtCore.QObject` \*>.

    .. _PySide.QtCore.QObject_no-copy-constructor-or-assignment-operator:



No copy constructor or assignment operator
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    :class:`PySide.QtCore.QObject` has neither a copy constructor nor an assignment operator. This is by design. Actually, they are declared, but in a ``private`` section with the macro :meth:`~PySide.QtCore.QObject.Q\_DISABLE\_COPY` . In fact, all Qt classes derived from :class:`PySide.QtCore.QObject` (direct or indirect) use this macro to declare their copy constructor and assignment operator to be private. The reasoning is found in the discussion on :ref:`Identity vs Value<object.html>` on the Qt :ref:`Object Model<object.html>` page.

    The main consequence is that you should use pointers to :class:`PySide.QtCore.QObject` (or to your :class:`PySide.QtCore.QObject` subclass) where you might otherwise be tempted to use your :class:`PySide.QtCore.QObject` subclass as a value. For example, without a copy constructor, you can't use a subclass of :class:`PySide.QtCore.QObject` as the value to be stored in one of the container classes. You must store pointers.

    .. _PySide.QtCore.QObject_auto-connection:



Auto-Connection
^^^^^^^^^^^^^^^

    Qt's meta-object system provides a mechanism to automatically connect signals and slots between :class:`PySide.QtCore.QObject` subclasses and their children. As long as objects are defined with suitable object names, and slots follow a simple naming convention, this connection can be performed at run-time by the :meth:`QMetaObject.connectSlotsByName()<PySide.QtCore.QMetaObject.connectSlotsByName>` function.

    :ref:`uic<uic.html>` generates code that invokes this function to enable auto-connection to be performed between widgets on forms created with *Qt Designer* . More information about using auto-connection with *Qt Designer* is given in the :ref:`Using a Designer UI File in Your Application<designer-using-a-ui-file.html>` section of the *Qt Designer* manual.

    .. _PySide.QtCore.QObject_dynamic-properties:



Dynamic Properties
^^^^^^^^^^^^^^^^^^

    From Qt 4.2, dynamic properties can be added to and removed from :class:`PySide.QtCore.QObject` instances at run-time. Dynamic properties do not need to be declared at compile-time, yet they provide the same advantages as static properties and are manipulated using the same API - using :meth:`PySide.QtCore.QObject.property` to read them and :meth:`PySide.QtCore.QObject.setProperty` to write them.

    From Qt 4.3, dynamic properties are supported by :ref:`Qt Designer<designer-widget-mode.html>` , and both standard Qt widgets and user-created forms can be given dynamic properties.

    .. _PySide.QtCore.QObject_internationalization-i18n:



Internationalization (i18n)
^^^^^^^^^^^^^^^^^^^^^^^^^^^

    All :class:`PySide.QtCore.QObject` subclasses support Qt's translation features, making it possible to translate an application's user interface into different languages.

    To make user-visible text translatable, it must be wrapped in calls to the :meth:`PySide.QtCore.QObject.tr` function. This is explained in detail in the :ref:`Writing Source Code for Translation<i18n-source-translation.html>` document.

    .. seealso::  :class:`PySide.QtCore.QMetaObject`  :class:`~PySide.QtCore.QPointer`  :class:`~PySide.QtCore.QObjectCleanupHandler`  :meth:`~PySide.QtCore.QObject.Q\_DISABLE\_COPY`  :ref:`Object Trees & Ownership<objecttrees.html>` 

.. class:: QObject([parent=None])

    :param parent: :class:`PySide.QtCore.QObject`

    Constructs an object with parent object ``parent`` .

    The parent of an object may be viewed as the object's owner. For instance, a :class:`dialog box<PySide.QtGui.QDialog>` is the parent of the **OK** and **Cancel** buttons it contains.

    The destructor of a parent object destroys all child objects.

    Setting ``parent`` to 0 constructs an object with no parent. If the object is a widget, it will become a top-level window.

    .. seealso::  :meth:`PySide.QtCore.QObject.parent`  :meth:`PySide.QtCore.QObject.findChild`  :meth:`PySide.QtCore.QObject.findChildren` 

.. method:: PySide.QtCore.QObject.blockSignals(b)


    :param b: :class:`PySide.QtCore.bool`
    :rtype: :class:`PySide.QtCore.bool`




    If ``block`` is true, signals emitted by this object are blocked (i.e., emitting a signal will not invoke anything connected to it). If ``block`` is false, no such blocking will occur.

    The return value is the previous value of :meth:`PySide.QtCore.QObject.signalsBlocked` .

    Note that the :meth:`PySide.QtCore.QObject.destroyed` signal will be emitted even if the signals for this object have been blocked.

    .. seealso::  :meth:`PySide.QtCore.QObject.signalsBlocked` 


.. method:: PySide.QtCore.QObject.childEvent(arg__1)


    :param arg__1: :class:`PySide.QtCore.QChildEvent`




    This event handler can be reimplemented in a subclass to receive child events. The event is passed in the ``event`` parameter.

    :attr:`QEvent.ChildAdded<QEvent.Type>` and :attr:`QEvent.ChildRemoved<QEvent.Type>` events are sent to objects when children are added or removed. In both cases you can only rely on the child being a :class:`PySide.QtCore.QObject` , or if :meth:`PySide.QtCore.QObject.isWidgetType` returns true, a :class:`PySide.QtGui.QWidget` . (This is because, in the :attr:`ChildAdded<QEvent.Type>` case, the child is not yet fully constructed, and in the :attr:`ChildRemoved<QEvent.Type>` case it might have been destructed already).

    :attr:`QEvent.ChildPolished<QEvent.Type>` events are sent to widgets when children are polished, or when polished children are added. If you receive a child polished event, the child's construction is usually completed. However, this is not guaranteed, and multiple polish events may be delivered during the execution of a widget's constructor.

    For every child widget, you receive one :attr:`ChildAdded<QEvent.Type>` event, zero or more :attr:`ChildPolished<QEvent.Type>` events, and one :attr:`ChildRemoved<QEvent.Type>` event.

    The :attr:`ChildPolished<QEvent.Type>` event is omitted if a child is removed immediately after it is added. If a child is polished several times during construction and destruction, you may receive several child polished events for the same child, each time with a different virtual table.

    .. seealso::  :meth:`PySide.QtCore.QObject.event` 


.. method:: PySide.QtCore.QObject.children()


    :rtype: 




    Returns a list of child objects. The :class:`~PySide.QtCore.QObjectList` class is defined in the ``<QObject>`` header file as the following:

    The first child added is the :meth:`QList.first` object in the list and the last child added is the :meth:`QList.last` object in the list, i.e. new children are appended at the end.

    Note that the list order changes when :class:`PySide.QtGui.QWidget` children are :meth:`raised<PySide.QtGui.QWidget.raise>` or :meth:`lowered<PySide.QtGui.QWidget.lower>` . A widget that is raised becomes the last object in the list, and a widget that is lowered becomes the first object in the list.

    .. seealso::  :meth:`PySide.QtCore.QObject.findChild`  :meth:`PySide.QtCore.QObject.findChildren`  :meth:`PySide.QtCore.QObject.parent`  :meth:`PySide.QtCore.QObject.setParent` 


.. method:: PySide.QtCore.QObject.connect(arg__1, arg__2, arg__3[, type=Qt.AutoConnection])


    :param arg__1: str
    :param arg__2: :class:`PySide.QtCore.QObject`
    :param arg__3: str
    :param type: :attr:`PySide.QtCore.Qt.ConnectionType`
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QObject.connect(arg__1, arg__2[, type=Qt.AutoConnection])


    :param arg__1: str
    :param arg__2: :class:`PyCallable`
    :param type: :attr:`PySide.QtCore.Qt.ConnectionType`
    :rtype: :class:`PySide.QtCore.bool`







.. staticmethod:: PySide.QtCore.QObject.connect(sender, signal, receiver, member[, type=Qt.AutoConnection])


    :param sender: :class:`PySide.QtCore.QObject`
    :param signal: str
    :param receiver: :class:`PySide.QtCore.QObject`
    :param member: str
    :param type: :attr:`PySide.QtCore.Qt.ConnectionType`
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QObject.connect(sender, signal, member[, type=Qt.AutoConnection])


    :param sender: :class:`PySide.QtCore.QObject`
    :param signal: str
    :param member: str
    :param type: :attr:`PySide.QtCore.Qt.ConnectionType`
    :rtype: :class:`PySide.QtCore.bool`







.. staticmethod:: PySide.QtCore.QObject.connect(arg__1, arg__2, arg__3[, type=Qt.AutoConnection])


    :param arg__1: :class:`PySide.QtCore.QObject`
    :param arg__2: str
    :param arg__3: :class:`PyCallable`
    :param type: :attr:`PySide.QtCore.Qt.ConnectionType`
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QObject.connectNotify(signal)


    :param signal: str




    This virtual function is called when something has been connected to ``signal`` in this object.

    If you want to compare ``signal`` with a specific signal, use :class:`~PySide.QtCore.QLatin1String` and the ``SIGNAL()`` macro as follows:

    ::

        if QLatin1String(signal) == SIGNAL('valueChanged()'):
            # signal is valueChanged()


    If the signal contains multiple parameters or parameters that contain spaces, call :meth:`QMetaObject.normalizedSignature()<PySide.QtCore.QMetaObject.normalizedSignature>` on the result of the ``SIGNAL()`` macro.

    .. warning::  This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.

    .. seealso::  :meth:`PySide.QtCore.QObject.connect`  :meth:`PySide.QtCore.QObject.disconnectNotify` 


.. method:: PySide.QtCore.QObject.customEvent(arg__1)


    :param arg__1: :class:`PySide.QtCore.QEvent`




    This event handler can be reimplemented in a subclass to receive custom events. Custom events are user-defined events with a type value at least as large as the :attr:`QEvent.User<QEvent.Type>` item of the :attr:`QEvent.Type` enum, and is typically a :class:`PySide.QtCore.QEvent` subclass. The event is passed in the ``event`` parameter.

    .. seealso::  :meth:`PySide.QtCore.QObject.event`  :class:`PySide.QtCore.QEvent` 


.. method:: PySide.QtCore.QObject.deleteLater()






    Schedules this object for deletion.

    The object will be deleted when control returns to the event loop. If the event loop is not running when this function is called (e.g. :meth:`PySide.QtCore.QObject.deleteLater` is called on an object before :meth:`QCoreApplication.exec()<PySide.QtCore.QCoreApplication.exec>` ), the object will be deleted once the event loop is started.

    Note that entering and leaving a new event loop (e.g., by opening a modal dialog) will *not* perform the deferred deletion; for the object to be deleted, the control must return to the event loop from which :meth:`PySide.QtCore.QObject.deleteLater` was called.

    .. note::  It is safe to call this function more than once; when the first deferred deletion event is delivered, any pending events for the object are removed from the event queue.

    .. seealso::  :meth:`PySide.QtCore.QObject.destroyed`  :class:`~PySide.QtCore.QPointer` 


.. method:: PySide.QtCore.QObject.destroyed([object=None])


    :param object: :class:`PySide.QtCore.QObject`






.. method:: PySide.QtCore.QObject.disconnect(signal, receiver, member)


    :param signal: str
    :param receiver: :class:`PySide.QtCore.QObject`
    :param member: str
    :rtype: :class:`PySide.QtCore.bool`




    This function overloads :meth:`PySide.QtCore.QObject.disconnect` .

    Disconnects ``signal`` from ``method`` of ``receiver`` .

    A signal-slot connection is removed when either of the objects involved are destroyed.



.. staticmethod:: PySide.QtCore.QObject.disconnect(sender, signal, receiver, member)


    :param sender: :class:`PySide.QtCore.QObject`
    :param signal: str
    :param receiver: :class:`PySide.QtCore.QObject`
    :param member: str
    :rtype: :class:`PySide.QtCore.bool`




    Disconnects ``signal`` in object ``sender`` from ``method`` in object ``receiver`` . Returns true if the connection is successfully broken; otherwise returns false.

    A signal-slot connection is removed when either of the objects involved are destroyed.

    :meth:`PySide.QtCore.QObject.disconnect` is typically used in three ways, as the following examples demonstrate.

    0 may be used as a wildcard, meaning "any signal", "any receiving object", or "any slot in the receiving object", respectively.

    The ``sender`` may never be 0. (You cannot disconnect signals from more than one object in a single call.)

    If ``signal`` is 0, it disconnects ``receiver`` and ``method`` from any signal. If not, only the specified signal is disconnected.

    If ``receiver`` is 0, it disconnects anything connected to ``signal`` . If not, slots in objects other than ``receiver`` are not disconnected.

    If ``method`` is 0, it disconnects anything that is connected to ``receiver`` . If not, only slots named ``method`` will be disconnected, and all other slots are left alone. The ``method`` must be 0 if ``receiver`` is left out, so you cannot disconnect a specifically-named slot on all objects.

    .. seealso::  :meth:`PySide.QtCore.QObject.connect` 


.. method:: PySide.QtCore.QObject.disconnect(arg__1, arg__2)


    :param arg__1: str
    :param arg__2: :class:`PyCallable`
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QObject.disconnect(receiver[, member=0])


    :param receiver: :class:`PySide.QtCore.QObject`
    :param member: str
    :rtype: :class:`PySide.QtCore.bool`




    This function overloads :meth:`PySide.QtCore.QObject.disconnect` .

    Disconnects all signals in this object from ``receiver`` 's ``method`` .

    A signal-slot connection is removed when either of the objects involved are destroyed.



.. staticmethod:: PySide.QtCore.QObject.disconnect(arg__1, arg__2, arg__3)


    :param arg__1: :class:`PySide.QtCore.QObject`
    :param arg__2: str
    :param arg__3: :class:`PyCallable`
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QObject.disconnectNotify(signal)


    :param signal: str




    This virtual function is called when something has been disconnected from ``signal`` in this object.

    See :meth:`PySide.QtCore.QObject.connectNotify` for an example of how to compare ``signal`` with a specific signal.

    .. warning::  This function violates the object-oriented principle of modularity. However, it might be useful for optimizing access to expensive resources.

    .. seealso::  :meth:`PySide.QtCore.QObject.disconnect`  :meth:`PySide.QtCore.QObject.connectNotify` 


.. method:: PySide.QtCore.QObject.dumpObjectInfo()






    Dumps information about signal connections, etc. for this object to the debug output.

    This function is useful for debugging, but does nothing if the library has been compiled in release mode (i.e. without debugging information).

    .. seealso::  :meth:`PySide.QtCore.QObject.dumpObjectTree` 


.. method:: PySide.QtCore.QObject.dumpObjectTree()






    Dumps a tree of children to the debug output.

    This function is useful for debugging, but does nothing if the library has been compiled in release mode (i.e. without debugging information).

    .. seealso::  :meth:`PySide.QtCore.QObject.dumpObjectInfo` 


.. method:: PySide.QtCore.QObject.dynamicPropertyNames()


    :rtype: 




    Returns the names of all properties that were dynamically added to the object using :meth:`PySide.QtCore.QObject.setProperty` .



.. method:: PySide.QtCore.QObject.emit(arg__1, arg__2)


    :param arg__1: str
    :param arg__2: :class:`...`
    :rtype: :class:`PySide.QtCore.bool`







.. method:: PySide.QtCore.QObject.event(arg__1)


    :param arg__1: :class:`PySide.QtCore.QEvent`
    :rtype: :class:`PySide.QtCore.bool`




    This virtual function receives events to an object and should return true if the event ``e`` was recognized and processed.

    The :meth:`PySide.QtCore.QObject.event` function can be reimplemented to customize the behavior of an object.

    .. seealso::  :meth:`PySide.QtCore.QObject.installEventFilter`  :meth:`PySide.QtCore.QObject.timerEvent`  :meth:`QApplication.sendEvent()<PySide.QtGui.QApplication.sendEvent>`  :meth:`QApplication.postEvent()<PySide.QtGui.QApplication.postEvent>`  :meth:`QWidget.event()<PySide.QtGui.QWidget.event>` 


.. method:: PySide.QtCore.QObject.eventFilter(arg__1, arg__2)


    :param arg__1: :class:`PySide.QtCore.QObject`
    :param arg__2: :class:`PySide.QtCore.QEvent`
    :rtype: :class:`PySide.QtCore.bool`




    Filters events if this object has been installed as an event filter for the ``watched`` object.

    In your reimplementation of this function, if you want to filter the ``event`` out, i.e. stop it being handled further, return true; otherwise return false.

    Example:

    ::

        class MainWindow(QMainWindow):
            def __init__(self):
                self.textEdit = QTextEdit()
                setCentralWidget(self.textEdit)
                textEdit.installEventFilter(self)

            def eventFilter(self, obj, event):
                if obj == textEdit:
                    if event.type() == QEvent.KeyPress:
                        keyEvent = event
                        print "Ate key press", keyEvent.key()
                        return true
                    else:
                        return false
                else:
                    # pass the event on to the parent class
                    return QMainWindow.eventFilter(self, obj, event)


    Notice in the example above that unhandled events are passed to the base class's :meth:`PySide.QtCore.QObject.eventFilter` function, since the base class might have reimplemented :meth:`PySide.QtCore.QObject.eventFilter` for its own internal purposes.

    .. warning::  If you delete the receiver object in this function, be sure to return true. Otherwise, Qt will forward the event to the deleted object and the program might crash.

    .. seealso::  :meth:`PySide.QtCore.QObject.installEventFilter` 


.. method:: PySide.QtCore.QObject.findChild(arg__1[, arg__2=""])


    :param arg__1: :class:`PyTypeObject`
    :param arg__2: unicode
    :rtype: :class:`PyObject`







.. method:: PySide.QtCore.QObject.findChildren(arg__1, arg__2)


    :param arg__1: :class:`PyTypeObject`
    :param arg__2: :class:`PySide.QtCore.QRegExp`
    :rtype: :class:`PySequence`







.. method:: PySide.QtCore.QObject.findChildren(arg__1[, arg__2=""])


    :param arg__1: :class:`PyTypeObject`
    :param arg__2: unicode
    :rtype: :class:`PySequence`







.. method:: PySide.QtCore.QObject.inherits(classname)


    :param classname: str
    :rtype: :class:`PySide.QtCore.bool`




    Returns true if this object is an instance of a class that inherits ``className`` or a :class:`PySide.QtCore.QObject` subclass that inherits ``className`` ; otherwise returns false.

    A class is considered to inherit itself.

    Example:

    ::

        timer = QTimer()                    # QTimer inherits QObject
        timer.inherits("QTimer")            # returns true
        timer.inherits("QObject")           # returns true
        timer.inherits("QAbstractButton")   # returns false

        # QLayout inherits QObject and QLayoutItem
        layout = QLayout()
        layout.inherits("QObject")          # returns true
        layout.inherits("QLayoutItem")      # returns false


    If you need to determine whether an object is an instance of a particular class for the purpose of casting it, consider using qobject\_cast<Type \*>(object) instead.

    .. seealso::  :meth:`PySide.QtCore.QObject.metaObject`  :meth:`~PySide.QtCore.QObject.qobject\_cast` 


.. method:: PySide.QtCore.QObject.installEventFilter(arg__1)


    :param arg__1: :class:`PySide.QtCore.QObject`




    Installs an event filter ``filterObj`` on this object. For example:

    ::

        monitoredObj.installEventFilter(filterObj)


    An event filter is an object that receives all events that are sent to this object. The filter can either stop the event or forward it to this object. The event filter ``filterObj`` receives events via its :meth:`PySide.QtCore.QObject.eventFilter` function. The :meth:`PySide.QtCore.QObject.eventFilter` function must return true if the event should be filtered, (i.e. stopped); otherwise it must return false.

    If multiple event filters are installed on a single object, the filter that was installed last is activated first.

    Here's a ``KeyPressEater`` class that eats the key presses of its monitored objects:

    ::

        class KeyPressEater(QObject):
            def eventFilter(self, obj, event):
                if event.type() == QEvent.KeyPress:
                    print "Ate key press", event.key()
                    return True
                else:
                    # standard event processing
                    return QObject.eventFilter(self, obj, event)


    And here's how to install it on two widgets:

    ::

        keyPressEater = KeyPressEater(self)
        pushButton = QPushButton(self)
        listView = QListView(self)

        pushButton.installEventFilter(keyPressEater)
        listView.installEventFilter(keyPressEater)


    The :class:`PySide.QtGui.QShortcut` class, for example, uses this technique to intercept shortcut key presses.

    .. warning::  If you delete the receiver object in your :meth:`PySide.QtCore.QObject.eventFilter` function, be sure to return true. If you return false, Qt sends the event to the deleted object and the program will crash.

    Note that the filtering object must be in the same thread as this object. If ``filterObj`` is in a different thread, this function does nothing. If either ``filterObj`` or this object are moved to a different thread after calling this function, the event filter will not be called until both objects have the same thread affinity again (it is *not* removed).

    .. seealso::  :meth:`PySide.QtCore.QObject.removeEventFilter`  :meth:`PySide.QtCore.QObject.eventFilter`  :meth:`PySide.QtCore.QObject.event` 


.. method:: PySide.QtCore.QObject.isWidgetType()


    :rtype: :class:`PySide.QtCore.bool`




    Returns true if the object is a widget; otherwise returns false.

    Calling this function is equivalent to calling inherits(" :class:`PySide.QtGui.QWidget` "), except that it is much faster.



.. method:: PySide.QtCore.QObject.killTimer(id)


    :param id: :class:`PySide.QtCore.int`




    Kills the timer with timer identifier, ``id`` .

    The timer identifier is returned by :meth:`PySide.QtCore.QObject.startTimer` when a timer event is started.

    .. seealso::  :meth:`PySide.QtCore.QObject.timerEvent`  :meth:`PySide.QtCore.QObject.startTimer` 


.. method:: PySide.QtCore.QObject.metaObject()


    :rtype: :class:`PySide.QtCore.QMetaObject`




    Returns a pointer to the meta-object of this object.

    A meta-object contains information about a class that inherits :class:`PySide.QtCore.QObject` , e.g. class name, superclass name, properties, signals and slots. Every :class:`PySide.QtCore.QObject` subclass that contains the :meth:`~PySide.QtCore.QObject.Q\_OBJECT` macro will have a meta-object.

    The meta-object information is required by the signal/slot connection mechanism and the property system. The :meth:`PySide.QtCore.QObject.inherits` function also makes use of the meta-object.

    If you have no pointer to an actual object instance but still want to access the meta-object of a class, you can use :ref:`staticMetaObject<qobject.html#staticMetaObject-var>` .

    Example:

    ::

        obj = QPushButton()
        obj.metaObject().className()                # returns "QPushButton"

        QPushButton.staticMetaObject.className()    # returns "QPushButton"


    .. seealso::  :ref:`staticMetaObject<qobject.html#staticMetaObject-var>` 


.. method:: PySide.QtCore.QObject.moveToThread(thread)


    :param thread: :class:`PySide.QtCore.QThread`




    Changes the thread affinity for this object and its children. The object cannot be moved if it has a parent. Event processing will continue in the ``targetThread`` .

    To move an object to the main thread, use :meth:`QApplication.instance()<PySide.QtGui.QApplication.instance>` to retrieve a pointer to the current application, and then use :meth:`QApplication.thread()<PySide.QtGui.QApplication.thread>` to retrieve the thread in which the application lives. For example:

    ::

        myObject.moveToThread(QApplication.instance().thread())


    If ``targetThread`` is zero, all event processing for this object and its children stops.

    Note that all active timers for the object will be reset. The timers are first stopped in the current thread and restarted (with the same interval) in the ``targetThread`` . As a result, constantly moving an object between threads can postpone timer events indefinitely.

    A :attr:`QEvent.ThreadChange<QEvent.Type>` event is sent to this object just before the thread affinity is changed. You can handle this event to perform any special processing. Note that any new events that are posted to this object will be handled in the ``targetThread`` .

    .. warning::  This function is *not* thread-safe; the current thread must be same as the current thread affinity. In other words, this function can only "push" an object from the current thread to another thread, it cannot "pull" an object from any arbitrary thread to the current thread.

    .. seealso::  :meth:`PySide.QtCore.QObject.thread` 


.. method:: PySide.QtCore.QObject.objectName()


    :rtype: unicode




    This property holds the name of this object.

    You can find an object by name (and type) using :meth:`PySide.QtCore.QObject.findChild` . You can find a set of objects with :meth:`PySide.QtCore.QObject.findChildren` .

    ::

        print "MyClass::setPrecision(): (%s) invalid precision %f" % \
               (qPrintable(objectName()), newPrecision)


    By default, this property contains an empty string.

    .. seealso::  :meth:`PySide.QtCore.QObject.metaObject`  :meth:`QMetaObject.className()<PySide.QtCore.QMetaObject.className>` 


.. method:: PySide.QtCore.QObject.parent()


    :rtype: :class:`PySide.QtCore.QObject`




    Returns a pointer to the parent object.

    .. seealso::  :meth:`PySide.QtCore.QObject.setParent`  :meth:`PySide.QtCore.QObject.children` 


.. method:: PySide.QtCore.QObject.property(name)


    :param name: str
    :rtype: object




    Returns the value of the object's ``name`` property.

    If no such property exists, the returned variant is invalid.

    Information about all available properties is provided through the :meth:`PySide.QtCore.QObject.metaObject` and :meth:`PySide.QtCore.QObject.dynamicPropertyNames` .

    .. seealso::  :meth:`PySide.QtCore.QObject.setProperty`  :meth:`QVariant.isValid`  :meth:`PySide.QtCore.QObject.metaObject`  :meth:`PySide.QtCore.QObject.dynamicPropertyNames` 


.. method:: PySide.QtCore.QObject.receivers(signal)


    :param signal: str
    :rtype: :class:`PySide.QtCore.int`




    Returns the number of receivers connected to the ``signal`` .

    Since both slots and signals can be used as receivers for signals, and the same connections can be made many times, the number of receivers is the same as the number of connections made from this signal.

    When calling this function, you can use the ``SIGNAL()`` macro to pass a specific signal:

    ::

        if receivers(SIGNAL('valueChanged()')) > 0:
            data = get_the_value()  # expensive operation
            self.valueChanged(data)


    As the code snippet above illustrates, you can use this function to avoid emitting a signal that nobody listens to.

    .. warning::  This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.



.. staticmethod:: PySide.QtCore.QObject.registerUserData()


    :rtype: :class:`PySide.QtCore.uint`






.. method:: PySide.QtCore.QObject.removeEventFilter(arg__1)


    :param arg__1: :class:`PySide.QtCore.QObject`




    Removes an event filter object ``obj`` from this object. The request is ignored if such an event filter has not been installed.

    All event filters for this object are automatically removed when this object is destroyed.

    It is always safe to remove an event filter, even during event filter activation (i.e. from the :meth:`PySide.QtCore.QObject.eventFilter` function).

    .. seealso::  :meth:`PySide.QtCore.QObject.installEventFilter`  :meth:`PySide.QtCore.QObject.eventFilter`  :meth:`PySide.QtCore.QObject.event` 


.. method:: PySide.QtCore.QObject.sender()


    :rtype: :class:`PySide.QtCore.QObject`




    Returns a pointer to the object that sent the signal, if called in a slot activated by a signal; otherwise it returns 0. The pointer is valid only during the execution of the slot that calls this function from this object's thread context.

    The pointer returned by this function becomes invalid if the sender is destroyed, or if the slot is disconnected from the sender's signal.

    .. warning::  This function violates the object-oriented principle of modularity. However, getting access to the sender might be useful when many signals are connected to a single slot.

    .. warning::  As mentioned above, the return value of this function is not valid when the slot is called via a :attr:`Qt.DirectConnection<Qt.ConnectionType>` from a thread different from this object's thread. Do not use this function in this type of scenario.

    .. seealso::  :class:`PySide.QtCore.QSignalMapper` 


.. method:: PySide.QtCore.QObject.setObjectName(name)


    :param name: unicode




    This property holds the name of this object.

    You can find an object by name (and type) using :meth:`PySide.QtCore.QObject.findChild` . You can find a set of objects with :meth:`PySide.QtCore.QObject.findChildren` .

    ::

        print "MyClass::setPrecision(): (%s) invalid precision %f" % \
               (qPrintable(objectName()), newPrecision)


    By default, this property contains an empty string.

    .. seealso::  :meth:`PySide.QtCore.QObject.metaObject`  :meth:`QMetaObject.className()<PySide.QtCore.QMetaObject.className>` 


.. method:: PySide.QtCore.QObject.setParent(arg__1)


    :param arg__1: :class:`PySide.QtCore.QObject`




    Makes the object a child of ``parent`` .

    .. seealso::  :meth:`PySide.QtCore.QObject.parent`  :meth:`QWidget.setParent()<PySide.QtGui.QWidget.setParent>` 


.. method:: PySide.QtCore.QObject.setProperty(name, value)


    :param name: str
    :param value: object
    :rtype: :class:`PySide.QtCore.bool`




    Sets the value of the object's ``name`` property to ``value`` .

    If the property is defined in the class using Q\_PROPERTY then true is returned on success and false otherwise. If the property is not defined using Q\_PROPERTY, and therefore not listed in the meta-object, it is added as a dynamic property and false is returned.

    Information about all available properties is provided through the :meth:`PySide.QtCore.QObject.metaObject` and :meth:`PySide.QtCore.QObject.dynamicPropertyNames` .

    Dynamic properties can be queried again using :meth:`PySide.QtCore.QObject.property` and can be removed by setting the property value to an invalid :class:`PySide.QtCore.QVariant` . Changing the value of a dynamic property causes a :class:`PySide.QtCore.QDynamicPropertyChangeEvent` to be sent to the object.

    .. note::  Dynamic properties starting with "\_q\_" are reserved for internal purposes.

    .. seealso::  :meth:`PySide.QtCore.QObject.property`  :meth:`PySide.QtCore.QObject.metaObject`  :meth:`PySide.QtCore.QObject.dynamicPropertyNames` 


.. method:: PySide.QtCore.QObject.signalsBlocked()


    :rtype: :class:`PySide.QtCore.bool`




    Returns true if signals are blocked; otherwise returns false.

    Signals are not blocked by default.

    .. seealso::  :meth:`PySide.QtCore.QObject.blockSignals` 


.. method:: PySide.QtCore.QObject.startTimer(interval)


    :param interval: :class:`PySide.QtCore.int`
    :rtype: :class:`PySide.QtCore.int`




    Starts a timer and returns a timer identifier, or returns zero if it could not start a timer.

    A timer event will occur every ``interval`` milliseconds until :meth:`PySide.QtCore.QObject.killTimer` is called. If ``interval`` is 0, then the timer event occurs once every time there are no more window system events to process.

    The virtual :meth:`PySide.QtCore.QObject.timerEvent` function is called with the :class:`PySide.QtCore.QTimerEvent` event parameter class when a timer event occurs. Reimplement this function to get timer events.

    If multiple timers are running, the :meth:`QTimerEvent.timerId()<PySide.QtCore.QTimerEvent.timerId>` can be used to find out which timer was activated.

    Example:

    ::

        class MyObject(QObject):
            def __init__(self, parent):
                QObject.__init__(self, parent)

                self.startTimer(50)         # 50-millisecond timer
                self.startTimer(1000)       # 1-second timer
                self.startTimer(60000)      # 1-minute timer


            def timerEvent(self, event):
                print "Timer ID:", event.timerId()



    Note that :class:`PySide.QtCore.QTimer` 's accuracy depends on the underlying operating system and hardware. Most platforms support an accuracy of 20 milliseconds; some provide more. If Qt is unable to deliver the requested number of timer events, it will silently discard some.

    The :class:`PySide.QtCore.QTimer` class provides a high-level programming interface with single-shot timers and timer signals instead of events. There is also a :class:`PySide.QtCore.QBasicTimer` class that is more lightweight than :class:`PySide.QtCore.QTimer` and less clumsy than using timer IDs directly.

    .. seealso::  :meth:`PySide.QtCore.QObject.timerEvent`  :meth:`PySide.QtCore.QObject.killTimer`  :meth:`QTimer.singleShot()<PySide.QtCore.QTimer.singleShot>` 


.. method:: PySide.QtCore.QObject.thread()


    :rtype: :class:`PySide.QtCore.QThread`




    Returns the thread in which the object lives.

    .. seealso::  :meth:`PySide.QtCore.QObject.moveToThread` 


.. method:: PySide.QtCore.QObject.timerEvent(arg__1)


    :param arg__1: :class:`PySide.QtCore.QTimerEvent`




    This event handler can be reimplemented in a subclass to receive timer events for the object.

    :class:`PySide.QtCore.QTimer` provides a higher-level interface to the timer functionality, and also more general information about timers. The timer event is passed in the ``event`` parameter.

    .. seealso::  :meth:`PySide.QtCore.QObject.startTimer`  :meth:`PySide.QtCore.QObject.killTimer`  :meth:`PySide.QtCore.QObject.event` 


.. method:: PySide.QtCore.QObject.tr(arg__1[, arg__2=0[, arg__3=-1]])


    :param arg__1: str
    :param arg__2: str
    :param arg__3: :class:`PySide.QtCore.int`
    :rtype: unicode




    Returns a translated version of ``sourceText`` , optionally based on a ``disambiguation`` string and value of ``n`` for strings containing plurals; otherwise returns ``sourceText`` itself if no appropriate translated string is available.

    Example:

    ::

        def createMenus(self):
            fileMenu = menuBar().addMenu("&File")
            ...


    If the same ``sourceText`` is used in different roles within the same context, an additional identifying string may be passed in ``disambiguation`` (0 by default). In Qt 4.4 and earlier, this was the preferred way to pass comments to translators.

    Example:

    ::

        def __init__(self):
            senderLabel = QLabel(self.tr("Name:"))
            recipientLabel = QLabel(self.tr("Name:", "recipient"))
            # ...
            ...


    See :ref:`Writing Source Code for Translation<i18n-source-translation.html>` for a detailed description of Qt's translation mechanisms in general, and the :ref:`Disambiguation<i18n-source-translation.html>` section for information on disambiguation.

    .. warning::  This method is reentrant only if all translators are installed *before* calling this method. Installing or removing translators while performing translations is not supported. Doing so will probably result in crashes or other undesirable behavior.

    .. seealso::  :meth:`PySide.QtCore.QObject.trUtf8`  :meth:`QApplication.translate()<PySide.QtGui.QApplication.translate>`  :meth:`QTextCodec.setCodecForTr()<PySide.QtCore.QTextCodec.setCodecForTr>`  :ref:`Internationalization with Qt<internationalization.html>` 


.. method:: PySide.QtCore.QObject.trUtf8(arg__1[, arg__2=0[, arg__3=-1]])


    :param arg__1: :class:`PyUnicode`
    :param arg__2: str
    :param arg__3: :class:`PySide.QtCore.int`
    :rtype: unicode







.. method:: PySide.QtCore.QObject.trUtf8(arg__1[, arg__2=0[, arg__3=-1]])


    :param arg__1: str
    :param arg__2: str
    :param arg__3: :class:`PySide.QtCore.int`
    :rtype: unicode




    Returns a translated version of ``sourceText`` , or QString::fromUtf8(``sourceText`` ) if there is no appropriate version. It is otherwise identical to tr(``sourceText`` , ``disambiguation`` , ``n`` ).

    Note that using the Utf8 variants of the translation functions is not required if ``CODECFORTR`` is already set to UTF-8 in the qmake project file and QTextCodec::setCodecForTr("UTF-8") is used.

    .. warning::  This method is reentrant only if all translators are installed *before* calling this method. Installing or removing translators while performing translations is not supported. Doing so will probably result in crashes or other undesirable behavior.

    .. warning::  For portability reasons, we recommend that you use escape sequences for specifying non-ASCII characters in string literals to :meth:`PySide.QtCore.QObject.trUtf8` . For example:

    ::

        label.setText(self.tr("F\374r \310lise"))


    .. seealso::  :meth:`PySide.QtCore.QObject.tr`  :meth:`QApplication.translate()<PySide.QtGui.QApplication.translate>`  :ref:`Internationalization with Qt<internationalization.html>` 



